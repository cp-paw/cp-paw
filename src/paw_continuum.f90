MODULE CONTINUUM_TESSELATION_MODULE
CHARACTER(10)          :: TESSID
INTEGER(4)             :: NPOINT
INTEGER(4)             :: NFACE
REAL(8)   ,ALLOCATABLE :: POINT(:,:)
INTEGER(4),ALLOCATABLE :: FACE(:,:)
END MODULE CONTINUUM_TESSELATION_MODULE
!
!.......................................................................
SUBROUTINE CONTINUUM_TESSELATION_GETI4(ID,VAL)
USE CONTINUUM_TESSELATION_MODULE
IMPLICIT NONE
CHARACTER(*),INTENT(IN) :: ID
INTEGER(4)  ,INTENT(OUT):: VAL
!***********************************************************************
IF(ID.EQ.'NPOINTS') THEN
  VAL=NPOINT
ELSE
  CALL ERROR$MSG('ID NOT RECOGNIZED')
  CALL ERROR$CHVAL('ID',ID)
  CALL ERROR$STOP('CONTINUUM_TESSELATION_GETI4')
END IF
RETURN
END
!
!.......................................................................
SUBROUTINE CONTINUUM_TESSELATION_SELECT(ID)
USE CONTINUUM_TESSELATION_MODULE
IMPLICIT NONE
CHARACTER(*),INTENT(IN) :: ID
!***********************************************************************
TESSID=ID
IF(ALLOCATED(POINT))DEALLOCATE(POINT)
IF(ALLOCATED(FACE))DEALLOCATE(FACE)

!=======================================================================
!==   DEFINE GRID POINTS AND FACES OF THE 32 TRIANGULATION            ==
!=======================================================================
IF(ID.EQ.'32') THEN
  NPOINT=32
  NFACE=60
  ALLOCATE(POINT(3,NPOINT))
  ALLOCATE(FACE(3,NFACE))
  POINT(:, 1)=(/ 0.000000000D+00, 0.000000000D+00, 0.100000000D+01/)
  POINT(:, 2)=(/ 0.000000000D+00, 0.000000000D+00, -.100000000D+01/)
  POINT(:, 3)=(/ 0.491123473D+00, 0.356822090D+00, 0.794654472D+00/)
  POINT(:, 4)=(/ -.187592474D+00, 0.577350269D+00, 0.794654472D+00/)
  POINT(:, 5)=(/ -.607061998D+00, 0.743436533D-16, 0.794654472D+00/)
  POINT(:, 6)=(/ -.187592474D+00, -.577350269D+00, 0.794654472D+00/)
  POINT(:, 7)=(/ 0.491123473D+00, -.356822090D+00, 0.794654472D+00/)
  POINT(:, 8)=(/ 0.894427191D+00, 0.000000000D+00, 0.447213595D+00/)
  POINT(:, 9)=(/ 0.276393202D+00, 0.850650808D+00, 0.447213595D+00/)
  POINT(:,10)=(/ -.723606798D+00, 0.525731112D+00, 0.447213595D+00/)
  POINT(:,11)=(/ -.723606798D+00, -.525731112D+00, 0.447213595D+00/)
  POINT(:,12)=(/ 0.276393202D+00, -.850650808D+00, 0.447213595D+00/)
  POINT(:,13)=(/ 0.794654472D+00, 0.577350269D+00, 0.187592474D+00/)
  POINT(:,14)=(/ -.303530999D+00, 0.934172359D+00, 0.187592474D+00/)
  POINT(:,15)=(/ -.982246946D+00, 0.120290558D-15, 0.187592474D+00/)
  POINT(:,16)=(/ -.303530999D+00, -.934172359D+00, 0.187592474D+00/)
  POINT(:,17)=(/ 0.794654472D+00, -.577350269D+00, 0.187592474D+00/)
  POINT(:,18)=(/ 0.982246946D+00, 0.000000000D+00, -.187592474D+00/)
  POINT(:,19)=(/ 0.303530999D+00, 0.934172359D+00, -.187592474D+00/)
  POINT(:,20)=(/ -.794654472D+00, 0.577350269D+00, -.187592474D+00/)
  POINT(:,21)=(/ -.794654472D+00, -.577350269D+00, -.187592474D+00/)
  POINT(:,22)=(/ 0.303530999D+00, -.934172359D+00, -.187592474D+00/)
  POINT(:,23)=(/ 0.723606798D+00, 0.525731112D+00, -.447213595D+00/)
  POINT(:,24)=(/ -.276393202D+00, 0.850650808D+00, -.447213595D+00/)
  POINT(:,25)=(/ -.894427191D+00, 0.109535740D-15, -.447213595D+00/)
  POINT(:,26)=(/ -.276393202D+00, -.850650808D+00, -.447213595D+00/)
  POINT(:,27)=(/ 0.723606798D+00, -.525731112D+00, -.447213595D+00/)
  POINT(:,28)=(/ 0.607061998D+00, 0.000000000D+00, -.794654472D+00/)
  POINT(:,29)=(/ 0.187592474D+00, 0.577350269D+00, -.794654472D+00/)
  POINT(:,30)=(/ -.491123473D+00, 0.356822090D+00, -.794654472D+00/)
  POINT(:,31)=(/ -.491123473D+00, -.356822090D+00, -.794654472D+00/)
  POINT(:,32)=(/ 0.187592474D+00, -.577350269D+00, -.794654472D+00/)
  FACE(:, 1)=(/ 1, 3, 4/)
  FACE(:, 2)=(/ 1, 3, 7/)
  FACE(:, 3)=(/ 1, 4, 5/)
  FACE(:, 4)=(/ 1, 5, 6/)
  FACE(:, 5)=(/ 1, 6, 7/)
  FACE(:, 6)=(/ 2,28,29/)
  FACE(:, 7)=(/ 2,28,32/)
  FACE(:, 8)=(/ 2,29,30/)
  FACE(:, 9)=(/ 2,30,31/)
  FACE(:,10)=(/ 2,31,32/)
  FACE(:,11)=(/ 3, 4, 9/)
  FACE(:,12)=(/ 3, 7, 8/)
  FACE(:,13)=(/ 3, 8,13/)
  FACE(:,14)=(/ 3, 9,13/)
  FACE(:,15)=(/ 4, 5,10/)
  FACE(:,16)=(/ 4, 9,14/)
  FACE(:,17)=(/ 4,10,14/)
  FACE(:,18)=(/ 5, 6,11/)
  FACE(:,19)=(/ 5,10,15/)
  FACE(:,20)=(/ 5,11,15/)
  FACE(:,21)=(/ 6, 7,12/)
  FACE(:,22)=(/ 6,11,16/)
  FACE(:,23)=(/ 6,12,16/)
  FACE(:,24)=(/ 7, 8,17/)
  FACE(:,25)=(/ 7,12,17/)
  FACE(:,26)=(/ 8,13,18/)
  FACE(:,27)=(/ 8,17,18/)
  FACE(:,28)=(/ 9,13,19/)
  FACE(:,29)=(/ 9,14,19/)
  FACE(:,30)=(/10,14,20/)
  FACE(:,31)=(/10,15,20/)
  FACE(:,32)=(/11,15,21/)
  FACE(:,33)=(/11,16,21/)
  FACE(:,34)=(/12,16,22/)
  FACE(:,35)=(/12,17,22/)
  FACE(:,36)=(/13,18,23/)
  FACE(:,37)=(/13,19,23/)
  FACE(:,38)=(/14,19,24/)
  FACE(:,39)=(/14,20,24/)
  FACE(:,40)=(/15,20,25/)
  FACE(:,41)=(/15,21,25/)
  FACE(:,42)=(/16,21,26/)
  FACE(:,43)=(/16,22,26/)
  FACE(:,44)=(/17,18,27/)
  FACE(:,45)=(/17,22,27/)
  FACE(:,46)=(/18,23,28/)
  FACE(:,47)=(/18,27,28/)
  FACE(:,48)=(/19,23,29/)
  FACE(:,49)=(/19,24,29/)
  FACE(:,50)=(/20,24,30/)
  FACE(:,51)=(/20,25,30/)
  FACE(:,52)=(/21,25,31/)
  FACE(:,53)=(/21,26,31/)
  FACE(:,54)=(/22,26,32/)
  FACE(:,55)=(/22,27,32/)
  FACE(:,56)=(/23,28,29/)
  FACE(:,57)=(/24,29,30/)
  FACE(:,58)=(/25,30,31/)
  FACE(:,59)=(/26,31,32/)
  FACE(:,60)=(/27,28,32/)
ELSE IF(ID.EQ.'122') THEN
  NPOINT=122
  NFACE=240
  ALLOCATE(POINT(3,NPOINT))
  ALLOCATE(FACE(3,NFACE))
  POINT(:,  1)=(/ 0.000000000D+00, 0.000000000D+00, 0.100000000D+01/)
  POINT(:,  2)=(/ 0.000000000D+00, 0.000000000D+00, -.100000000D+01/)
  POINT(:,  3)=(/ 0.491123473D+00, 0.356822090D+00, 0.794654472D+00/)
  POINT(:,  4)=(/ -.187592474D+00, 0.577350269D+00, 0.794654472D+00/)
  POINT(:,  5)=(/ -.607061998D+00, 0.743436533D-16, 0.794654472D+00/)
  POINT(:,  6)=(/ -.187592474D+00, -.577350269D+00, 0.794654472D+00/)
  POINT(:,  7)=(/ 0.491123473D+00, -.356822090D+00, 0.794654472D+00/)
  POINT(:,  8)=(/ 0.894427191D+00, 0.000000000D+00, 0.447213595D+00/)
  POINT(:,  9)=(/ 0.276393202D+00, 0.850650808D+00, 0.447213595D+00/)
  POINT(:, 10)=(/ -.723606798D+00, 0.525731112D+00, 0.447213595D+00/)
  POINT(:, 11)=(/ -.723606798D+00, -.525731112D+00, 0.447213595D+00/)
  POINT(:, 12)=(/ 0.276393202D+00, -.850650808D+00, 0.447213595D+00/)
  POINT(:, 13)=(/ 0.794654472D+00, 0.577350269D+00, 0.187592474D+00/)
  POINT(:, 14)=(/ -.303530999D+00, 0.934172359D+00, 0.187592474D+00/)
  POINT(:, 15)=(/ -.982246946D+00, 0.120290558D-15, 0.187592474D+00/)
  POINT(:, 16)=(/ -.303530999D+00, -.934172359D+00, 0.187592474D+00/)
  POINT(:, 17)=(/ 0.794654472D+00, -.577350269D+00, 0.187592474D+00/)
  POINT(:, 18)=(/ 0.982246946D+00, 0.000000000D+00, -.187592474D+00/)
  POINT(:, 19)=(/ 0.303530999D+00, 0.934172359D+00, -.187592474D+00/)
  POINT(:, 20)=(/ -.794654472D+00, 0.577350269D+00, -.187592474D+00/)
  POINT(:, 21)=(/ -.794654472D+00, -.577350269D+00, -.187592474D+00/)
  POINT(:, 22)=(/ 0.303530999D+00, -.934172359D+00, -.187592474D+00/)
  POINT(:, 23)=(/ 0.723606798D+00, 0.525731112D+00, -.447213595D+00/)
  POINT(:, 24)=(/ -.276393202D+00, 0.850650808D+00, -.447213595D+00/)
  POINT(:, 25)=(/ -.894427191D+00, 0.109535740D-15, -.447213595D+00/)
  POINT(:, 26)=(/ -.276393202D+00, -.850650808D+00, -.447213595D+00/)
  POINT(:, 27)=(/ 0.723606798D+00, -.525731112D+00, -.447213595D+00/)
  POINT(:, 28)=(/ 0.607061998D+00, 0.000000000D+00, -.794654472D+00/)
  POINT(:, 29)=(/ 0.187592474D+00, 0.577350269D+00, -.794654472D+00/)
  POINT(:, 30)=(/ -.491123473D+00, 0.356822090D+00, -.794654472D+00/)
  POINT(:, 31)=(/ -.491123473D+00, -.356822090D+00, -.794654472D+00/)
  POINT(:, 32)=(/ 0.187592474D+00, -.577350269D+00, -.794654472D+00/)
  POINT(:, 33)=(/ 0.259230007D+00, 0.188341624D+00, 0.947273580D+00/)
  POINT(:, 34)=(/ -.990170517D-01, 0.304743150D+00, 0.947273580D+00/)
  POINT(:, 35)=(/ -.320425910D+00, 0.392408565D-16, 0.947273580D+00/)
  POINT(:, 36)=(/ -.990170517D-01, -.304743150D+00, 0.947273580D+00/)
  POINT(:, 37)=(/ 0.259230007D+00, -.188341624D+00, 0.947273580D+00/)
  POINT(:, 38)=(/ 0.320425910D+00, 0.000000000D+00, -.947273580D+00/)
  POINT(:, 39)=(/ 0.990170517D-01, 0.304743150D+00, -.947273580D+00/)
  POINT(:, 40)=(/ -.259230007D+00, 0.188341624D+00, -.947273580D+00/)
  POINT(:, 41)=(/ -.259230007D+00, -.188341624D+00, -.947273580D+00/)
  POINT(:, 42)=(/ 0.990170517D-01, -.304743150D+00, -.947273580D+00/)
  POINT(:, 43)=(/ 0.162459848D+00, 0.500000000D+00, 0.850650808D+00/)
  POINT(:, 44)=(/ 0.525731112D+00, -.594228150D-16, 0.850650808D+00/)
  POINT(:, 45)=(/ 0.731336064D+00, 0.188341624D+00, 0.655495991D+00/)
  POINT(:, 46)=(/ 0.405118802D+00, 0.637341167D+00, 0.655495991D+00/)
  POINT(:, 47)=(/ 0.688190960D+00, 0.500000000D+00, 0.525731112D+00/)
  POINT(:, 48)=(/ -.425325404D+00, 0.309016994D+00, 0.850650808D+00/)
  POINT(:, 49)=(/ 0.468717433D-01, 0.753742692D+00, 0.655495991D+00/)
  POINT(:, 50)=(/ -.480958875D+00, 0.582240128D+00, 0.655495991D+00/)
  POINT(:, 51)=(/ -.262865556D+00, 0.809016994D+00, 0.525731112D+00/)
  POINT(:, 52)=(/ -.425325404D+00, -.309016994D+00, 0.850650808D+00/)
  POINT(:, 53)=(/ -.702367734D+00, 0.277496978D+00, 0.655495991D+00/)
  POINT(:, 54)=(/ -.702367734D+00, -.277496978D+00, 0.655495991D+00/)
  POINT(:, 55)=(/ -.850650808D+00, 0.104174679D-15, 0.525731112D+00/)
  POINT(:, 56)=(/ 0.162459848D+00, -.500000000D+00, 0.850650808D+00/)
  POINT(:, 57)=(/ -.480958875D+00, -.582240128D+00, 0.655495991D+00/)
  POINT(:, 58)=(/ 0.468717433D-01, -.753742692D+00, 0.655495991D+00/)
  POINT(:, 59)=(/ -.262865556D+00, -.809016994D+00, 0.525731112D+00/)
  POINT(:, 60)=(/ 0.731336064D+00, -.188341624D+00, 0.655495991D+00/)
  POINT(:, 61)=(/ 0.405118802D+00, -.637341167D+00, 0.655495991D+00/)
  POINT(:, 62)=(/ 0.688190960D+00, -.500000000D+00, 0.525731112D+00/)
  POINT(:, 63)=(/ 0.891549019D+00, 0.304743150D+00, 0.335070080D+00/)
  POINT(:, 64)=(/ 0.891549019D+00, -.304743150D+00, 0.335070080D+00/)
  POINT(:, 65)=(/ 0.990566071D+00, 0.000000000D+00, 0.137035977D+00/)
  POINT(:, 66)=(/ 0.565331757D+00, 0.753742692D+00, 0.335070080D+00/)
  POINT(:, 67)=(/ -.143241601D-01, 0.942084317D+00, 0.335070080D+00/)
  POINT(:, 68)=(/ 0.306101750D+00, 0.942084317D+00, 0.137035977D+00/)
  POINT(:, 69)=(/ -.542154779D+00, 0.770581752D+00, 0.335070080D+00/)
  POINT(:, 70)=(/ -.900401837D+00, 0.277496978D+00, 0.335070080D+00/)
  POINT(:, 71)=(/ -.801384785D+00, 0.582240128D+00, 0.137035977D+00/)
  POINT(:, 72)=(/ -.900401837D+00, -.277496978D+00, 0.335070080D+00/)
  POINT(:, 73)=(/ -.542154779D+00, -.770581752D+00, 0.335070080D+00/)
  POINT(:, 74)=(/ -.801384785D+00, -.582240128D+00, 0.137035977D+00/)
  POINT(:, 75)=(/ -.143241601D-01, -.942084317D+00, 0.335070080D+00/)
  POINT(:, 76)=(/ 0.565331757D+00, -.753742692D+00, 0.335070080D+00/)
  POINT(:, 77)=(/ 0.306101750D+00, -.942084317D+00, 0.137035977D+00/)
  POINT(:, 78)=(/ 0.951056516D+00, 0.309016994D+00, 0.594228150D-16/)
  POINT(:, 79)=(/ 0.587785252D+00, 0.809016994D+00, 0.594228150D-16/)
  POINT(:, 80)=(/ 0.801384785D+00, 0.582240128D+00, -.137035977D+00/)
  POINT(:, 81)=(/ 0.891342224D-16, 0.100000000D+01, 0.594228150D-16/)
  POINT(:, 82)=(/ -.587785252D+00, 0.809016994D+00, 0.594228150D-16/)
  POINT(:, 83)=(/ -.306101750D+00, 0.942084317D+00, -.137035977D+00/)
  POINT(:, 84)=(/ -.951056516D+00, 0.309016994D+00, 0.594228150D-16/)
  POINT(:, 85)=(/ -.951056516D+00, -.309016994D+00, 0.594228150D-16/)
  POINT(:, 86)=(/ -.990566071D+00, 0.121309357D-15, -.137035977D+00/)
  POINT(:, 87)=(/ -.587785252D+00, -.809016994D+00, 0.594228150D-16/)
  POINT(:, 88)=(/ -.207979852D-15, -.100000000D+01, 0.594228150D-16/)
  POINT(:, 89)=(/ -.306101750D+00, -.942084317D+00, -.137035977D+00/)
  POINT(:, 90)=(/ 0.951056516D+00, -.309016994D+00, 0.594228150D-16/)
  POINT(:, 91)=(/ 0.587785252D+00, -.809016994D+00, 0.594228150D-16/)
  POINT(:, 92)=(/ 0.801384785D+00, -.582240128D+00, -.137035977D+00/)
  POINT(:, 93)=(/ 0.900401837D+00, 0.277496978D+00, -.335070080D+00/)
  POINT(:, 94)=(/ 0.900401837D+00, -.277496978D+00, -.335070080D+00/)
  POINT(:, 95)=(/ 0.850650808D+00, 0.000000000D+00, -.525731112D+00/)
  POINT(:, 96)=(/ 0.542154779D+00, 0.770581752D+00, -.335070080D+00/)
  POINT(:, 97)=(/ 0.143241601D-01, 0.942084317D+00, -.335070080D+00/)
  POINT(:, 98)=(/ 0.262865556D+00, 0.809016994D+00, -.525731112D+00/)
  POINT(:, 99)=(/ -.565331757D+00, 0.753742692D+00, -.335070080D+00/)
  POINT(:,100)=(/ -.891549019D+00, 0.304743150D+00, -.335070080D+00/)
  POINT(:,101)=(/ -.688190960D+00, 0.500000000D+00, -.525731112D+00/)
  POINT(:,102)=(/ -.891549019D+00, -.304743150D+00, -.335070080D+00/)
  POINT(:,103)=(/ -.565331757D+00, -.753742692D+00, -.335070080D+00/)
  POINT(:,104)=(/ -.688190960D+00, -.500000000D+00, -.525731112D+00/)
  POINT(:,105)=(/ 0.143241601D-01, -.942084317D+00, -.335070080D+00/)
  POINT(:,106)=(/ 0.542154779D+00, -.770581752D+00, -.335070080D+00/)
  POINT(:,107)=(/ 0.262865556D+00, -.809016994D+00, -.525731112D+00/)
  POINT(:,108)=(/ 0.702367734D+00, 0.277496978D+00, -.655495991D+00/)
  POINT(:,109)=(/ 0.480958875D+00, 0.582240128D+00, -.655495991D+00/)
  POINT(:,110)=(/ -.468717433D-01, 0.753742692D+00, -.655495991D+00/)
  POINT(:,111)=(/ -.405118802D+00, 0.637341167D+00, -.655495991D+00/)
  POINT(:,112)=(/ -.731336064D+00, 0.188341624D+00, -.655495991D+00/)
  POINT(:,113)=(/ -.731336064D+00, -.188341624D+00, -.655495991D+00/)
  POINT(:,114)=(/ -.405118802D+00, -.637341167D+00, -.655495991D+00/)
  POINT(:,115)=(/ -.468717433D-01, -.753742692D+00, -.655495991D+00/)
  POINT(:,116)=(/ 0.702367734D+00, -.277496978D+00, -.655495991D+00/)
  POINT(:,117)=(/ 0.480958875D+00, -.582240128D+00, -.655495991D+00/)
  POINT(:,118)=(/ 0.425325404D+00, 0.309016994D+00, -.850650808D+00/)
  POINT(:,119)=(/ 0.425325404D+00, -.309016994D+00, -.850650808D+00/)
  POINT(:,120)=(/ -.162459848D+00, 0.500000000D+00, -.850650808D+00/)
  POINT(:,121)=(/ -.525731112D+00, 0.891342224D-16, -.850650808D+00/)
  POINT(:,121)=(/ -.162459848D+00, -.500000000D+00, -.850650808D+00/)
  FACE(:,  1)=(/  1, 33, 34/)
  FACE(:,  2)=(/  1, 33, 37/)
  FACE(:,  3)=(/  1, 34, 35/)
  FACE(:,  4)=(/  1, 35, 36/)
  FACE(:,  5)=(/  1, 36, 37/)
  FACE(:,  6)=(/  2, 38, 39/)
  FACE(:,  7)=(/  2, 38, 42/)
  FACE(:,  8)=(/  2, 39, 40/)
  FACE(:,  9)=(/  2, 40, 41/)
  FACE(:, 10)=(/  2, 41, 42/)
  FACE(:, 11)=(/  3, 33, 43/)
  FACE(:, 12)=(/  3, 33, 44/)
  FACE(:, 13)=(/  3, 43, 46/)
  FACE(:, 14)=(/  3, 44, 45/)
  FACE(:, 15)=(/  3, 45, 47/)
  FACE(:, 16)=(/  3, 46, 47/)
  FACE(:, 17)=(/  4, 34, 43/) 
  FACE(:, 18)=(/  4, 34, 48/)
  FACE(:, 19)=(/  4, 43, 49/)
  FACE(:, 20)=(/  4, 48, 50/)
  FACE(:, 21)=(/  4, 49, 51/)
  FACE(:, 22)=(/  4, 50, 51/)
  FACE(:, 23)=(/  5, 35, 48/)
  FACE(:, 24)=(/  5, 35, 52/)
  FACE(:, 25)=(/  5, 48, 53/)
  FACE(:, 26)=(/  5, 52, 54/)
  FACE(:, 27)=(/  5, 53, 55/)
  FACE(:, 28)=(/  5, 54, 55/)
  FACE(:, 29)=(/  6, 36, 52/)
  FACE(:, 30)=(/  6, 36, 56/)
  FACE(:, 31)=(/  6, 52, 57/)
  FACE(:, 32)=(/  6, 56, 58/)
  FACE(:, 33)=(/  6, 57, 59/)
  FACE(:, 34)=(/  6, 58, 59/)
  FACE(:, 35)=(/  7, 37, 44/)
  FACE(:, 36)=(/  7, 37, 56/)
  FACE(:, 37)=(/  7, 44, 60/)
  FACE(:, 38)=(/  7, 56, 61/)
  FACE(:, 39)=(/  7, 60, 62/)
  FACE(:, 40)=(/  7, 61, 62/)
  FACE(:, 41)=(/  8, 45, 60/)
  FACE(:, 42)=(/  8, 45, 63/)
  FACE(:, 43)=(/  8, 60, 64/)
  FACE(:, 44)=(/  8, 63, 65/)
  FACE(:, 45)=(/  8, 64, 65/)
  FACE(:, 46)=(/  9, 46, 49/)
  FACE(:, 47)=(/  9, 46, 66/)
  FACE(:, 48)=(/  9, 49, 67/)
  FACE(:, 49)=(/  9, 66, 68/)
  FACE(:, 50)=(/  9, 67, 68/)
  FACE(:, 51)=(/ 10, 50, 53/)
  FACE(:, 52)=(/ 10, 50, 69/)
  FACE(:, 53)=(/ 10, 53, 70/)
  FACE(:, 54)=(/ 10, 69, 71/)
  FACE(:, 55)=(/ 10, 70, 71/)
  FACE(:, 56)=(/ 11, 54, 57/)
  FACE(:, 57)=(/ 11, 54, 72/)
  FACE(:, 58)=(/ 11, 57, 73/)
  FACE(:, 59)=(/ 11, 72, 74/)
  FACE(:, 60)=(/ 11, 73, 74/)
  FACE(:, 61)=(/ 12, 58, 61/)
  FACE(:, 62)=(/ 12, 58, 75/)
  FACE(:, 63)=(/ 12, 61, 76/)
  FACE(:, 64)=(/ 12, 75, 77/)
  FACE(:, 65)=(/ 12, 76, 77/)
  FACE(:, 66)=(/ 13, 47, 63/)
  FACE(:, 67)=(/ 13, 47, 66/)
  FACE(:, 68)=(/ 13, 63, 78/)
  FACE(:, 69)=(/ 13, 66, 79/)
  FACE(:, 70)=(/ 13, 78, 80/) 
  FACE(:, 71)=(/ 13, 79, 80/)
  FACE(:, 72)=(/ 14, 51, 67/)
  FACE(:, 73)=(/ 14, 51, 69/)
  FACE(:, 74)=(/ 14, 67, 81/)
  FACE(:, 75)=(/ 14, 69, 82/)
  FACE(:, 76)=(/ 14, 81, 83/)
  FACE(:, 77)=(/ 14, 82, 83/)
  FACE(:, 78)=(/ 15, 55, 70/)
  FACE(:, 79)=(/ 15, 55, 72/)
  FACE(:, 80)=(/ 15, 70, 84/)
  FACE(:, 81)=(/ 15, 72, 85/)
  FACE(:, 82)=(/ 15, 84, 86/)
  FACE(:, 83)=(/ 15, 85, 86/)
  FACE(:, 84)=(/ 16, 59, 73/)
  FACE(:, 85)=(/ 16, 59, 75/)
  FACE(:, 86)=(/ 16, 73, 87/)
  FACE(:, 87)=(/ 16, 75, 88/)
  FACE(:, 88)=(/ 16, 87, 89/)
  FACE(:, 89)=(/ 16, 88, 89/)
  FACE(:, 90)=(/ 17, 62, 64/)
  FACE(:, 91)=(/ 17, 62, 76/)
  FACE(:, 92)=(/ 17, 64, 90/)
  FACE(:, 93)=(/ 17, 76, 91/)
  FACE(:, 94)=(/ 17, 90, 92/)
  FACE(:, 95)=(/ 17, 91, 92/)
  FACE(:, 96)=(/ 18, 65, 78/)
  FACE(:, 97)=(/ 18, 65, 90/)
  FACE(:, 98)=(/ 18, 78, 93/)
  FACE(:, 99)=(/ 18, 90, 94/)
  FACE(:,100)=(/ 18, 93, 95/)
  FACE(:,101)=(/ 18, 94, 95/)
  FACE(:,102)=(/ 19, 68, 79/)
  FACE(:,103)=(/ 19, 68, 81/)
  FACE(:,104)=(/ 19, 79, 96/)
  FACE(:,105)=(/ 19, 81, 97/)
  FACE(:,106)=(/ 19, 96, 98/)
  FACE(:,107)=(/ 19, 97, 98/)
  FACE(:,108)=(/ 20, 71, 82/)
  FACE(:,109)=(/ 20, 71, 84/)
  FACE(:,110)=(/ 20, 82, 99/)
  FACE(:,111)=(/ 20, 84,100/)
  FACE(:,112)=(/ 20, 99,101/)
  FACE(:,113)=(/ 20,100,101/)
  FACE(:,114)=(/ 21, 74, 85/)
  FACE(:,115)=(/ 21, 74, 87/)
  FACE(:,116)=(/ 21, 85,102/)
  FACE(:,117)=(/ 21, 87,103/)
  FACE(:,118)=(/ 21,102,104/)
  FACE(:,119)=(/ 21,103,104/)
  FACE(:,120)=(/ 22, 77, 88/)
  FACE(:,121)=(/ 22, 77, 91/)
  FACE(:,122)=(/ 22, 88,105/)
  FACE(:,123)=(/ 22, 91,106/)
  FACE(:,124)=(/ 22,105,107/)
  FACE(:,125)=(/ 22,106,107/)
  FACE(:,126)=(/ 23, 80, 93/)
  FACE(:,127)=(/ 23, 80, 96/)
  FACE(:,128)=(/ 23, 93,108/)
  FACE(:,129)=(/ 23, 96,109/)
  FACE(:,130)=(/ 23,108,109/)
  FACE(:,131)=(/ 24, 83, 97/)
  FACE(:,132)=(/ 24, 83, 99/)
  FACE(:,133)=(/ 24, 97,110/)
  FACE(:,134)=(/ 24, 99,111/)
  FACE(:,135)=(/ 24,110,111/)
  FACE(:,136)=(/ 25, 86,100/)
  FACE(:,137)=(/ 25, 86,102/)
  FACE(:,138)=(/ 25,100,112/)
  FACE(:,139)=(/ 25,102,113/)
  FACE(:,140)=(/ 25,112,113/)
  FACE(:,141)=(/ 26, 89,103/)
  FACE(:,142)=(/ 26, 89,105/)
  FACE(:,143)=(/ 26,103,114/)
  FACE(:,144)=(/ 26,105,115/)
  FACE(:,145)=(/ 26,114,115/)
  FACE(:,146)=(/ 27, 92, 94/)
  FACE(:,147)=(/ 27, 92,106/)
  FACE(:,148)=(/ 27, 94,116/)
  FACE(:,149)=(/ 27,106,117/)
  FACE(:,150)=(/ 27,116,117/)
  FACE(:,151)=(/ 28, 38,118/)
  FACE(:,152)=(/ 28, 38,119/)
  FACE(:,153)=(/ 28, 95,108/)
  FACE(:,154)=(/ 28, 95,116/)
  FACE(:,155)=(/ 28,108,118/)
  FACE(:,156)=(/ 28,116,119/)
  FACE(:,157)=(/ 29, 39,118/)
  FACE(:,158)=(/ 29, 39,120/)
  FACE(:,159)=(/ 29, 98,109/)
  FACE(:,160)=(/ 29, 98,110/)
  FACE(:,161)=(/ 29,109,118/)
  FACE(:,162)=(/ 29,110,120/)
  FACE(:,163)=(/ 30, 40,120/)
  FACE(:,164)=(/ 30, 40,121/)
  FACE(:,165)=(/ 30,101,111/)
  FACE(:,166)=(/ 30,101,112/)
  FACE(:,167)=(/ 30,111,120/)
  FACE(:,168)=(/ 30,112,121/)
  FACE(:,169)=(/ 31, 41,121/)
  FACE(:,170)=(/ 31, 41,122/)
  FACE(:,171)=(/ 31,104,113/)
  FACE(:,172)=(/ 31,104,114/)
  FACE(:,173)=(/ 31,113,121/)
  FACE(:,174)=(/ 31,114,122/)
  FACE(:,175)=(/ 32, 42,119/)
  FACE(:,176)=(/ 32, 42,122/)
  FACE(:,177)=(/ 32,107,115/)
  FACE(:,178)=(/ 32,107,117/)
  FACE(:,179)=(/ 32,115,122/)
  FACE(:,180)=(/ 32,117,119/)
  FACE(:,181)=(/ 33, 34, 43/)
  FACE(:,182)=(/ 33, 37, 44/)
  FACE(:,183)=(/ 34, 35, 48/)
  FACE(:,184)=(/ 35, 36, 52/)
  FACE(:,185)=(/ 36, 37, 56/)
  FACE(:,186)=(/ 38, 39,118/)
  FACE(:,187)=(/ 38, 42,119/)
  FACE(:,188)=(/ 39, 40,120/)
  FACE(:,189)=(/ 40, 41,121/)
  FACE(:,190)=(/ 41, 42,122/)
  FACE(:,191)=(/ 43, 46, 49/)
  FACE(:,192)=(/ 44, 45, 60/)
  FACE(:,193)=(/ 45, 47, 63/)
  FACE(:,194)=(/ 46, 47, 66/)
  FACE(:,195)=(/ 48, 50, 53/)
  FACE(:,196)=(/ 49, 51, 67/)
  FACE(:,197)=(/ 50, 51, 69/)
  FACE(:,198)=(/ 52, 54, 57/)
  FACE(:,199)=(/ 53, 55, 70/)
  FACE(:,200)=(/ 54, 55, 72/)
  FACE(:,201)=(/ 56, 58, 61/)
  FACE(:,202)=(/ 57, 59, 73/)
  FACE(:,203)=(/ 58, 59, 75/)
  FACE(:,204)=(/ 60, 62, 64/)
  FACE(:,205)=(/ 61, 62, 76/)
  FACE(:,206)=(/ 63, 65, 78/)
  FACE(:,207)=(/ 64, 65, 90/)
  FACE(:,208)=(/ 66, 68, 79/)
  FACE(:,209)=(/ 67, 68, 81/)
  FACE(:,210)=(/ 69, 71, 82/)
  FACE(:,211)=(/ 70, 71, 84/)
  FACE(:,212)=(/ 72, 74, 85/)
  FACE(:,213)=(/ 73, 74, 87/)
  FACE(:,214)=(/ 75, 77, 88/)
  FACE(:,215)=(/ 76, 77, 91/)
  FACE(:,216)=(/ 78, 80, 93/)
  FACE(:,217)=(/ 79, 80, 96/)
  FACE(:,218)=(/ 81, 83, 97/)
  FACE(:,219)=(/ 82, 83, 99/)
  FACE(:,220)=(/ 84, 86,100/)
  FACE(:,221)=(/ 85, 86,102/)
  FACE(:,222)=(/ 87, 89,103/)
  FACE(:,223)=(/ 88, 89,105/)
  FACE(:,224)=(/ 90, 92, 94/)
  FACE(:,225)=(/ 91, 92,106/)
  FACE(:,226)=(/ 93, 95,108/)
  FACE(:,227)=(/ 94, 95,116/)
  FACE(:,228)=(/ 96, 98,109/)
  FACE(:,229)=(/ 97, 98,110/)
  FACE(:,230)=(/ 99,101,111/)
  FACE(:,231)=(/100,101,112/)
  FACE(:,232)=(/102,104,113/)
  FACE(:,233)=(/103,104,114/)
  FACE(:,234)=(/105,107,115/)
  FACE(:,235)=(/106,107,117/)
  FACE(:,236)=(/108,109,118/)
  FACE(:,237)=(/110,111,120/)
  FACE(:,238)=(/112,113,121/)
  FACE(:,239)=(/114,115,122/)
  FACE(:,240)=(/116,117,119/)
ELSE
  CALL ERROR$MSG('ID NOT RECOGNIZED')
  CALL ERROR$CHVAL('ID',ID)
  CALL ERROR$STOP('CONTINUUM_TESSELATION_SELECT')
END IF
RETURN
END


!     =======================================================================
!     ====================   CONTROL MODULE FOR CONTINUUM   =================
!     =======================================================================
!
      MODULE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
!
      PRIVATE
      PUBLIC REPORT_CONTINUUM_CONTROLS
      PUBLIC GET_SET_RESTART,GET_SET_MOVENETCHARGES,GET_SET_STOPNETCHARGES
      PUBLIC GET_SET_FZO,GET_SET_ON,GET_SET_MOVEATOMS,GET_SET_SURFACEMASS
      PUBLIC GET_SET_SCALINGFACTOR,GET_SET_RSOLV,GET_SET_ACCSURFACE
      PUBLIC GET_SET_TESSNAME,GET_SET_CHARGEFRICTION,GET_SET_SMALLESTMIDP
      PUBLIC GET_SET_TIMESTEP,GET_SET_SURFACE_AREA,GET_THERMOSTAT,SET_THERMOSTAT
      PUBLIC GET_CHARGE,SET_CHARGE,GET_SET_MULTIPLE
!
      LOGICAL,SAVE :: RESTART
      LOGICAL,SAVE :: MOVE_NETCHARGES
      LOGICAL,SAVE :: STOP_NETCHARGES
      LOGICAL,SAVE :: FORCE_ZERO_OVERLAP
      LOGICAL,SAVE :: ON=.FALSE.,STOP,AUTO,MOVE_ATOMS
      LOGICAL,SAVE :: NOSE_THERMOSTAT=.FALSE.,STOP_NOSE_THERMOSTAT
      REAL(8),SAVE  :: MASS
      REAL(8),SAVE  :: SMALLEST_MIDPOINT_DISTANCE
      REAL(8),SAVE  :: TIMESTEP
      REAL(8),SAVE  :: CHARGE_FRICTION
      REAL(8),SAVE  :: NETCHARGE,INSIDE_CHARGE,POSITIVE_CHARGE,&
       &NEGATIVE_CHARGE,POSITIVE_CHARGE_INSIDE,NEGATIVE_CHARGE_INSIDE,&
       &SCALING_FACTOR,SURFACE_AREA
      REAL(8),SAVE  :: AVERAGE_KINETIC,NOSE_FREQUENCY
      REAL(8),ALLOCATABLE,SAVE,DIMENSION(:)  :: RSOLV,ACCSURFACE
      INTEGER(4)    :: MULTIPLE
      CHARACTER(8),ALLOCATABLE,SAVE,DIMENSION(:) :: TESSELATION_NAME
!
      CONTAINS
!
!     =======================================================================
!
      SUBROUTINE GET_SET_RSOLV(GS,NUMBER,R)
      IMPLICIT NONE
      CHARACTER(*) :: GS
      INTEGER(4) :: NUMBER,COUNTER
      REAL(8) :: R(NUMBER)
      LOGICAL,SAVE :: TFIRST=.TRUE.
!
      IF (TFIRST) THEN
       TFIRST=.FALSE.
       ALLOCATE(RSOLV(NUMBER))
      ENDIF
      IF (GS == 'SET') THEN
       DO COUNTER=1,NUMBER
        RSOLV(COUNTER)=R(COUNTER)
       ENDDO
      ELSE
       DO COUNTER=1,NUMBER
        R(COUNTER)=RSOLV(COUNTER)
       ENDDO
      ENDIF
!
      END SUBROUTINE GET_SET_RSOLV
!
!     =======================================================================
!
      SUBROUTINE GET_SET_MULTIPLE(GS,MULTIPLE_)
      IMPLICIT NONE
      CHARACTER(*) :: GS
      INTEGER(4) :: MULTIPLE_
!
      IF (GS == 'SET') THEN
       MULTIPLE=MULTIPLE_
      ELSE
       MULTIPLE_=MULTIPLE
      ENDIF
!
      END SUBROUTINE GET_SET_MULTIPLE
!
!     =======================================================================
!
      SUBROUTINE GET_SET_ACCSURFACE(GS,NUMBER,SURFACE)
      IMPLICIT NONE
      CHARACTER(*) :: GS
      INTEGER(4) :: NUMBER,COUNTER
      REAL(8) :: SURFACE(NUMBER)
      LOGICAL,SAVE :: TFIRST=.TRUE.
!
      IF (TFIRST) THEN
       TFIRST=.FALSE.
       ALLOCATE(ACCSURFACE(NUMBER))
      ENDIF
      IF (GS == 'SET') THEN
       DO COUNTER=1,NUMBER
        ACCSURFACE(COUNTER)=SURFACE(COUNTER)
       ENDDO
      ELSE
       DO COUNTER=1,NUMBER
        SURFACE(COUNTER)=ACCSURFACE(COUNTER)
       ENDDO
      ENDIF
!
      END SUBROUTINE GET_SET_ACCSURFACE
!
!     =======================================================================
!
      SUBROUTINE GET_SET_TESSNAME(GS,NUMBER,TESSNAME)
      IMPLICIT NONE
      CHARACTER(*) :: GS
      INTEGER(4) :: NUMBER,COUNTER
      CHARACTER(8) :: TESSNAME(NUMBER)
      LOGICAL,SAVE :: TFIRST=.TRUE.
!
      IF (TFIRST) THEN
       TFIRST=.FALSE.
       ALLOCATE(TESSELATION_NAME(NUMBER))
      ENDIF
      IF (GS == 'SET') THEN
       DO COUNTER=1,NUMBER
        TESSELATION_NAME(COUNTER)=TESSNAME(COUNTER)
       ENDDO
      ELSE
       DO COUNTER=1,NUMBER
        TESSNAME(COUNTER)=TESSELATION_NAME(COUNTER)
       ENDDO
      ENDIF
!
      END SUBROUTINE GET_SET_TESSNAME
!
!     =======================================================================
!
      SUBROUTINE GET_CHARGE(NET_Q,INSIDE_Q,POS_Q,NEG_Q,INSIDE_POS_Q,&
           &INSIDE_NEG_Q)
      IMPLICIT NONE
      REAL(8), INTENT(OUT) ::NET_Q,INSIDE_Q,POS_Q,NEG_Q,INSIDE_POS_Q,&
           &INSIDE_NEG_Q
!
      NET_Q=NETCHARGE
      INSIDE_Q=INSIDE_CHARGE
      POS_Q=POSITIVE_CHARGE
      NEG_Q=NEGATIVE_CHARGE
      INSIDE_POS_Q=POSITIVE_CHARGE_INSIDE
      INSIDE_NEG_Q=NEGATIVE_CHARGE_INSIDE
!
      END SUBROUTINE GET_CHARGE
!
!     =======================================================================
!
      SUBROUTINE SET_CHARGE(NET_Q,INSIDE_Q,POS_Q,NEG_Q,INSIDE_POS_Q,&
           &INSIDE_NEG_Q)
      IMPLICIT NONE
      REAL(8), INTENT(IN) ::NET_Q,INSIDE_Q,POS_Q,NEG_Q,INSIDE_POS_Q,&
           &INSIDE_NEG_Q
!
      NETCHARGE=NET_Q
      INSIDE_CHARGE=INSIDE_Q
      POSITIVE_CHARGE=POS_Q
      NEGATIVE_CHARGE=NEG_Q
      POSITIVE_CHARGE_INSIDE=INSIDE_POS_Q
      NEGATIVE_CHARGE_INSIDE=INSIDE_NEG_Q
!
      END SUBROUTINE SET_CHARGE
!
!     =======================================================================
!
      SUBROUTINE GET_SET_SCALINGFACTOR(GS,SF)
      IMPLICIT NONE
      REAL(8)              ::SF
      CHARACTER(*)         :: GS
!
      IF (GS == 'GET') THEN
       SF=SCALING_FACTOR
      ELSE
       SCALING_FACTOR=SF
      ENDIF
!
      END SUBROUTINE GET_SET_SCALINGFACTOR
!
!
!     =======================================================================
!
      SUBROUTINE GET_SET_SMALLESTMIDP(GS,DISTANCE)
      IMPLICIT NONE
      REAL(8),INTENT(INOUT) :: DISTANCE
      CHARACTER(*) :: GS
!
      IF (GS == 'SET') THEN
       SMALLEST_MIDPOINT_DISTANCE=DISTANCE
      ELSE
       DISTANCE=SMALLEST_MIDPOINT_DISTANCE
      ENDIF
!
      END SUBROUTINE GET_SET_SMALLESTMIDP
!
!     =======================================================================
!
      SUBROUTINE GET_SET_SURFACE_AREA(SET,AREA)
      IMPLICIT NONE
      LOGICAL,INTENT(IN) :: SET
      REAL(8),INTENT(INOUT) :: AREA
!
      IF (SET) THEN
       SURFACE_AREA=AREA
      ELSE
       AREA=SURFACE_AREA
      ENDIF
!
      END SUBROUTINE GET_SET_SURFACE_AREA
!
!     =======================================================================
!
      SUBROUTINE SET_THERMOSTAT(ON,STOP,EKIN,FREQ)
      IMPLICIT NONE
      LOGICAL,INTENT(IN) :: ON,STOP
      REAL(8),INTENT(IN) :: EKIN,FREQ
!
      AVERAGE_KINETIC=EKIN
      NOSE_FREQUENCY=FREQ
      NOSE_THERMOSTAT=ON
      STOP_NOSE_THERMOSTAT=STOP
!
      END SUBROUTINE SET_THERMOSTAT
!
!     =======================================================================
!
      SUBROUTINE GET_THERMOSTAT(ON,STOP,EKIN,FREQ)
      IMPLICIT NONE
      LOGICAL,INTENT(OUT) :: ON,STOP
      REAL(8),INTENT(OUT) :: EKIN,FREQ
!
      EKIN=AVERAGE_KINETIC
      FREQ=NOSE_FREQUENCY
      ON=NOSE_THERMOSTAT
      STOP=STOP_NOSE_THERMOSTAT
!
      END SUBROUTINE GET_THERMOSTAT
!
!     =======================================================================
!
      SUBROUTINE GET_SET_TIMESTEP(GS,DELT)
      IMPLICIT NONE
      REAL(8)       :: DELT
      CHARACTER(*)  :: GS
!
      IF (GS == 'SET') THEN
       TIMESTEP=DELT
      ELSE
       DELT=TIMESTEP
      ENDIF
!
      END SUBROUTINE GET_SET_TIMESTEP
!
!     =======================================================================
!
      SUBROUTINE GET_SET_CHARGEFRICTION(GS,FRIC)
      IMPLICIT NONE
      REAL(8),INTENT(INOUT) :: FRIC
      CHARACTER(*)  :: GS
!
      IF (GS == 'SET') THEN
       CHARGE_FRICTION=FRIC 
      ELSE
       FRIC=CHARGE_FRICTION
      ENDIF
!
      END SUBROUTINE GET_SET_CHARGEFRICTION
!
!     =======================================================================
!
      SUBROUTINE REPORT_CONTINUUM_CONTROLS
      IMPLICIT NONE
      INTEGER :: NFILO
!
      CALL FILEHANDLER$UNIT('PROT',NFILO)
      WRITE(NFILO,*)
      WRITE(NFILO,*)'================ CONTINUUM CONTROLS =================='
      IF (ON) THEN
       WRITE(NFILO,*)'CONTINUUM MODELING OF ELECTROSTATIC SOLVATION IS'&
         &,' ->ON'
      ELSE
       WRITE(NFILO,*)'CONTINUUM MODELING OF ELECTROSTATIC SOLVATION IS'&
         &,' ->OFF'
      ENDIF
      IF (RESTART) THEN
       WRITE(NFILO,*)'MESH DATA READ FROM RESTART FILE'
      ELSE
       WRITE(NFILO,*)'MESH TO BE GENERATED AROUND IONS READ FROM INPUT'
      ENDIF
      IF (MOVE_NETCHARGES) THEN
       WRITE(NFILO,*)'CHARGES ON MESH ARE MOBILE'
      ELSE
       WRITE(NFILO,*)'CHARGES ON MESH ARE FIXED'
      ENDIF
      IF (MULTIPLE > 1) THEN
       WRITE(NFILO,*)'MULTIPLE TIMESTEP INTEGRATION FOR SURFACE CHARGES IS ON'
       WRITE(NFILO,*)'OVERSAMPLING FACTOR : ',MULTIPLE
      ENDIF
      IF (FORCE_ZERO_OVERLAP) THEN
       WRITE(NFILO,*)'ZERO FACE CHARGE ENFORCED IN OVERLAP REGION'
      ENDIF
      IF (AUTO) THEN
       WRITE(NFILO,*)'CONVERGENCE SPED UP BY VARIABLE FRICTION'
      ENDIF
      WRITE(NFILO,FMT='(" FINITE DIELECTRIC SCALING:",F12.6)')&
      & SCALING_FACTOR
      IF (MOVE_ATOMS) THEN
       WRITE(NFILO,*)'FORCES ON NUCLEI DUE TO SOLVATION WILL BE COMPUTED'
      ENDIF
      WRITE(NFILO,FMT='(" FICTITIOUS MASS OF CHARGE DENSITY :",F12.6)')&
      & MASS
      WRITE(NFILO,*)
      IF (NOSE_THERMOSTAT) THEN
       WRITE(NFILO,FMT='(" NOSE THERMOSTAT FOR CHARGES IS ACTIVE")')
       IF (STOP_NOSE_THERMOSTAT) THEN
        WRITE(NFILO,FMT='(" NOSE VARIABLE IS STOPPED")')
       ENDIF
       WRITE(NFILO,FMT='(" AVERAGE KINETIC ENERGY OF CHARGES:",F12.6)')&
    &                     AVERAGE_KINETIC
       WRITE(NFILO,FMT='(" FREQUENCY OF NOSE VARIABLE       :",F12.6)')&
        &   NOSE_FREQUENCY
      ENDIF
      WRITE(NFILO,*)'===================================================='
      WRITE(NFILO,*)
!
      END SUBROUTINE REPORT_CONTINUUM_CONTROLS
!
!     =======================================================================
!
      SUBROUTINE GET_SET_RESTART(GS,FLAG)
      IMPLICIT NONE
      LOGICAL :: FLAG
      CHARACTER(*) :: GS
!
      IF (GS == 'GET') THEN
       FLAG=RESTART
      ELSE
       RESTART=FLAG
      ENDIF
!
      END SUBROUTINE GET_SET_RESTART
!
!     =======================================================================
!
      SUBROUTINE GET_SET_MOVEATOMS(GS,FLAG)
      IMPLICIT NONE
      LOGICAL      :: FLAG
      CHARACTER(*) :: GS
!
      IF (GS == 'GET') THEN
       FLAG=MOVE_ATOMS
      ELSE
       MOVE_ATOMS=FLAG
      ENDIF
!
      END SUBROUTINE GET_SET_MOVEATOMS
!
!     =======================================================================
!
      SUBROUTINE GET_SET_SURFACEMASS(GS,VAR)
      IMPLICIT NONE
      REAL(8), INTENT(INOUT) :: VAR
      CHARACTER(*) :: GS
!
      IF (GS == 'GET') THEN
       VAR=MASS
      ELSE
       MASS=VAR
      ENDIF
!
      END SUBROUTINE GET_SET_SURFACEMASS
!
!     =======================================================================
!
      SUBROUTINE GET_SET_STOPNETCHARGES(GS,FLAG)
      IMPLICIT NONE
      LOGICAL :: FLAG
      CHARACTER(*) :: GS
!
      IF (GS == 'GET') THEN
       FLAG=STOP_NETCHARGES
      ELSE
       STOP_NETCHARGES=FLAG
      ENDIF
!
      END SUBROUTINE GET_SET_STOPNETCHARGES
!
!     =======================================================================
!
      SUBROUTINE GET_SET_MOVENETCHARGES(GS,FLAG)
      IMPLICIT NONE
      LOGICAL :: FLAG
      CHARACTER(*) :: GS
!
      IF (GS == 'GET') THEN
       FLAG=MOVE_NETCHARGES
      ELSE
       MOVE_NETCHARGES=FLAG
      ENDIF
!
      END SUBROUTINE GET_SET_MOVENETCHARGES
!
!     =======================================================================
!
      SUBROUTINE GET_SET_FZO(GS,FLAG)
      IMPLICIT NONE
      LOGICAL :: FLAG
      CHARACTER(*) :: GS
!
      IF (GS == 'GET') THEN
       FLAG=FORCE_ZERO_OVERLAP
      ELSE
       FORCE_ZERO_OVERLAP=FLAG
      ENDIF
!
      END SUBROUTINE GET_SET_FZO
!
!     =======================================================================
!
      SUBROUTINE GET_SET_ON(GS,FLAG)
      IMPLICIT NONE
      LOGICAL :: FLAG
      CHARACTER(*) :: GS
!
      IF (GS == 'GET') THEN
       FLAG=ON
      ELSE
       ON=FLAG
      ENDIF
!
      END SUBROUTINE GET_SET_ON
!
!     =======================================================================
!
      END MODULE CONTINUUM_CONTROL_MODULE
!
!     =======================================================================
!     ====================END CONTROL MODULE FOR CONTINUUM  =================
!     =======================================================================
!
!
!     =======================================================================
!     ======================= NET MODULE FOR CONTINUUM  =====================
!     =======================================================================
!
      MODULE NET_MODULE
      PRIVATE
      TYPE FACETYPE
        TYPE (FACETYPE),  POINTER  :: NEXT
        TYPE (FACETYPE),  POINTER  :: PREV
        INTEGER(4)                  :: IDENT
        INTEGER(4)                  :: ATOM_IDENT
        REAL(8)                     :: Q
        REAL(8)                     :: QP
        REAL(8)                     :: QM
        REAL(8)                     :: FQ
        REAL(8)                     :: FMEM
        REAL(8)                     :: AREA
        REAL(8)                     :: MIDPOINT(3)
        REAL(8),DIMENSION(3)        :: TRI1,TRI2,TRI3
      END TYPE FACETYPE
      TYPE (FACETYPE),POINTER    :: FIRSTFACE
      TYPE (FACETYPE),POINTER    :: LASTFACE
!
!     MAKE IT PUBLIC
!
      PUBLIC FACETYPE
      PUBLIC FIRSTFACE,LASTFACE
      PUBLIC NET_REPORT
      PUBLIC GET_FACE_NUMBER
      PUBLIC CONTINUUM_READ,CONTINUUM_WRITE
      PUBLIC STOP_NETCHARGES,FORCES_AND_ENERGY
      PUBLIC MIDPOINT_DISTANCE,READ_TESSELATION
!
      CONTAINS
!
!     =============================================================== 
!
      SUBROUTINE NET_REPORT(NAT,R0)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      INTEGER,INTENT(IN) :: NAT
      REAL(8),DIMENSION(3,NAT) :: R0
      TYPE (FACETYPE),POINTER    :: FACE
      CHARACTER*30 :: MATLAB_STRING
      CHARACTER*32 :: NAME
      INTEGER             :: COUNT,COUNT2,IAT,VI,NFILO
      INTEGER             :: IDENT1,IDENT2,FACECOUNTER
      INTEGER, DIMENSION(:), POINTER :: MAP
      INTEGER   :: MATLAB_INDEX=0
      LOGICAL   :: DETAILED=.FALSE.
      LOGICAL   :: FACE_INFO=.TRUE.
      LOGICAL   :: MATLAB_INFO=.TRUE.
      LOGICAL   :: SURFACE_PLOT=.TRUE.
      LOGICAL   :: DEPTH_PLOT=.TRUE.,INSIDE
      REAL(8)    :: DISTANCE
      REAL(8)    :: SURFACE_AREA
      REAL(8),ALLOCATABLE,DIMENSION(:) :: RSOLV,ACCSURFACE
      SAVE MATLAB_INDEX
!     
      CALL GET_FACE_NUMBER(FACECOUNTER)
      CALL GET_SET_SURFACE_AREA(.FALSE.,SURFACE_AREA)
      CALL FILEHANDLER$UNIT('PROT',NFILO)
      WRITE(NFILO,*)"=====================NET REPORT==================="
      WRITE(NFILO,*)'NUMBER OF FACES  : ',FACECOUNTER
      ALLOCATE(RSOLV(NAT))
      ALLOCATE(ACCSURFACE(NAT))
      CALL GET_SET_RSOLV('GET',NAT,RSOLV)
      CALL GET_SET_ACCSURFACE('GET',NAT,ACCSURFACE)
      DO IAT=1,NAT
       CALL ATOMLIST$GET('NAME',32,IAT,NAME)
       WRITE(NFILO,FMT='("RSOLV(",A4,") = ",F6.3,' &
     &       //'"     ACC. SURFACE(",A4,") = ",F8.3)') &
     &      NAME,RSOLV(IAT),NAME,ACCSURFACE(IAT)
      ENDDO
      WRITE(NFILO,*)
      WRITE(NFILO,FMT='("SURFACE AREA OF SOLUTE :",F12.6," AU^2")')&
       &SURFACE_AREA
      IF (DETAILED) THEN
       WRITE(NFILO,*)'DETAILED REPORT FOLLOWS ....'
      ENDIF
!     
      IF (MATLAB_INFO) THEN
       MATLAB_INDEX=MATLAB_INDEX+1
       WRITE(MATLAB_STRING,FMT='("MATOUT",I3.3)')MATLAB_INDEX
       OPEN(40,FILE=MATLAB_STRING)
       WRITE(MATLAB_STRING,FMT='("MATINS",I3.3)')MATLAB_INDEX
       OPEN(41,FILE=MATLAB_STRING)
       FACE=>FIRSTFACE
       DO WHILE (ASSOCIATED(FACE))
        INSIDE=.FALSE.
        DO IAT=1,NAT
         IF (FACE%ATOM_IDENT /= IAT) THEN
          DISTANCE=DSQRT((FACE%MIDPOINT(1)-R0(1,IAT))**2+&
           &(FACE%MIDPOINT(2)-R0(2,IAT))**2 +&
           &(FACE%MIDPOINT(3)-R0(3,IAT))**2)
          IF (DISTANCE < RSOLV(IAT)) THEN
           INSIDE=.TRUE.
          ENDIF
         ENDIF
        ENDDO
        IF (DEPTH_PLOT .AND. INSIDE) THEN
         WRITE(41,FMT='(10(1X,E12.6),I4)')FACE%MIDPOINT+FACE%TRI1,&
          &FACE%MIDPOINT+FACE%TRI2,FACE%MIDPOINT+FACE%TRI3,&
          &FACE%Q,FACE%ATOM_IDENT
        ENDIF
        IF (SURFACE_PLOT .AND. .NOT. INSIDE) THEN
         WRITE(40,FMT='(10(1X,E12.6),I4)')FACE%MIDPOINT+FACE%TRI1,&
          &FACE%MIDPOINT+FACE%TRI2,FACE%MIDPOINT+FACE%TRI3,&
          &FACE%Q,FACE%ATOM_IDENT
        ENDIF
        FACE=>FACE%NEXT
       ENDDO
       CLOSE(40)
       CLOSE(41)
      ENDIF
      IF (DETAILED) THEN
       IF (FACE_INFO) THEN
        FACE=>FIRSTFACE
        DO WHILE (ASSOCIATED(FACE))
         WRITE(*,FMT='("FACE  : ",1X,I4)')FACE%IDENT
         WRITE(*,FMT='("ATOM  : ",1X,I6)')FACE%ATOM_IDENT
         WRITE(*,FMT='("AREA  : ",1X,E15.9)')FACE%AREA
         WRITE(*,FMT='("CHRGDN: ",1X,E15.9)')FACE%Q
         WRITE(*,FMT='("Q_F   : ",1X,E15.9)')FACE%FQ
         WRITE(*,FMT='("MIDPT : ",3(1X,E15.9))')FACE%MIDPOINT
         FACE=> FACE%NEXT
        ENDDO
       ENDIF
      ENDIF
      DEALLOCATE(RSOLV)
      DEALLOCATE(ACCSURFACE)
!
      END SUBROUTINE NET_REPORT
!
!     =============================================================== 
!
      SUBROUTINE GET_FACE_NUMBER(NFACE)
      INTEGER(4),INTENT(OUT) ::NFACE
      TYPE (FACETYPE),POINTER :: FACE
!
      NFACE=0
      FACE=> FIRSTFACE
      DO WHILE (ASSOCIATED(FACE))
       NFACE=NFACE+1
       FACE=>FACE%NEXT
      ENDDO
!
      END SUBROUTINE GET_FACE_NUMBER
!
!     =============================================================== 
!
      SUBROUTINE MAKEFACE(FACE,ITERATION)
      TYPE (FACETYPE),POINTER :: FACE
      INTEGER                 :: ITERATION
      NULLIFY(FACE)
      ALLOCATE(FACE)
      IF(ASSOCIATED(LASTFACE)) THEN
       LASTFACE%NEXT=>FACE 
       FACE%PREV=>LASTFACE
       FACE%IDENT=LASTFACE%IDENT+1
      ELSE
       FIRSTFACE=>FACE
       NULLIFY(FACE%PREV)
       FACE%IDENT=1
      END IF
      NULLIFY(FACE%NEXT)
      FACE%ATOM_IDENT=ITERATION
      FACE%Q=0.D0
      FACE%QM=0.D0
      FACE%QP=0.D0
!      WRITE(*,*)'CAUTION: FINITE CHARGE FUDGE!!!!'
!      FACE%Q=-0.01D0
!      FACE%QM=-0.01D0
!      FACE%QP=-0.01D0
      LASTFACE=>FACE
!
      END SUBROUTINE MAKEFACE
!
!     =============================================================== 
!
      SUBROUTINE UNMAKEFACE(FACE)
      TYPE (FACETYPE),POINTER :: FACE
      TYPE (FACETYPE),POINTER :: PREVFACE,NEXTFACE
      INTEGER(4)               :: STAT
!
      IF(ASSOCIATED(FACE,LASTFACE)) THEN
        LASTFACE=>FACE%PREV
        NULLIFY(LASTFACE%NEXT)
      ELSE
        FACE%NEXT%PREV=>FACE%PREV
      END IF
      IF(ASSOCIATED(FACE,FIRSTFACE)) THEN
        FIRSTFACE=>FACE%NEXT
        NULLIFY(FIRSTFACE%PREV)
      ELSE 
        FACE%PREV%NEXT=>FACE%NEXT
      END IF
      NULLIFY(FACE%PREV)
      NULLIFY(FACE%NEXT)
      DEALLOCATE(FACE,STAT=STAT)
      IF(STAT.NE.0)THEN;
        PRINT*,'STAT ',STAT
        STOP 'IN UNMAKELINE'
      ENDIF
!
      END SUBROUTINE UNMAKEFACE
!
!     -------------------------------------------------------------------
!
      SUBROUTINE CONTINUUM_WRITE(NFIL)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      TYPE (FACETYPE), POINTER :: FACE
      INTEGER                  :: NFACE,COUNTER
      INTEGER, INTENT(IN) :: NFIL
      INTEGER,ALLOCATABLE,DIMENSION(:) :: FACE_IDENT
      INTEGER,ALLOCATABLE,DIMENSION(:) :: FACE_ATOM_IDENT
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: FACE_MIDPOINT
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: FACE_TRI1
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: FACE_TRI2
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: FACE_TRI3
      REAL(8),ALLOCATABLE,DIMENSION(:) :: FACE_AREA
      REAL(8),ALLOCATABLE,DIMENSION(:) :: FACE_Q
      REAL(8),ALLOCATABLE,DIMENSION(:) :: FACE_QM
      REAL(8),ALLOCATABLE,DIMENSION(:) :: FACE_FMEM
      INTEGER(4)                       :: NTASKS,THISTASK
      LOGICAL                          :: ON
!
      CALL GET_FACE_NUMBER(NFACE)
      ALLOCATE(FACE_IDENT(NFACE))
      ALLOCATE(FACE_ATOM_IDENT(NFACE))
      ALLOCATE(FACE_MIDPOINT(3,NFACE))
      ALLOCATE(FACE_TRI1(3,NFACE))
      ALLOCATE(FACE_TRI2(3,NFACE))
      ALLOCATE(FACE_TRI3(3,NFACE))
      ALLOCATE(FACE_AREA(NFACE))
      ALLOCATE(FACE_Q(NFACE))
      ALLOCATE(FACE_QM(NFACE))
      ALLOCATE(FACE_FMEM(NFACE))
!
      FACE=>FIRSTFACE
      COUNTER=1
      DO WHILE (ASSOCIATED(FACE))
       FACE_IDENT(COUNTER)=FACE%IDENT
       FACE_ATOM_IDENT(COUNTER)=FACE%ATOM_IDENT
       FACE_MIDPOINT(:,COUNTER)=FACE%MIDPOINT(:)
       FACE_TRI1(:,COUNTER)=FACE%TRI1(:)
       FACE_TRI2(:,COUNTER)=FACE%TRI2(:)
       FACE_TRI3(:,COUNTER)=FACE%TRI3(:)
       FACE_AREA(COUNTER)=FACE%AREA
       FACE_Q(COUNTER)=FACE%Q
       FACE_QM(COUNTER)=FACE%QM
       FACE_FMEM(COUNTER)=FACE%FMEM
       COUNTER=COUNTER+1
       FACE=>FACE%NEXT
      ENDDO
!
      WRITE(NFIL)NFACE
!
      WRITE(NFIL)FACE_IDENT,FACE_ATOM_IDENT,FACE_MIDPOINT,&
         & FACE_TRI1,FACE_TRI2,FACE_TRI3,FACE_AREA,FACE_Q,FACE_QM,FACE_FMEM
!
!
      DEALLOCATE(FACE_IDENT)
      DEALLOCATE(FACE_ATOM_IDENT)
      DEALLOCATE(FACE_MIDPOINT)
      DEALLOCATE(FACE_TRI1)
      DEALLOCATE(FACE_TRI2)
      DEALLOCATE(FACE_TRI3)
      DEALLOCATE(FACE_AREA)
      DEALLOCATE(FACE_Q)
      DEALLOCATE(FACE_QM)
      DEALLOCATE(FACE_FMEM)
!
      END SUBROUTINE CONTINUUM_WRITE
!
!     -------------------------------------------------------------------
!
      SUBROUTINE CONTINUUM_READ(NFIL)
      USE CONTINUUM_CONTROL_MODULE
      USE MPE_MODULE
      IMPLICIT NONE
      TYPE (FACETYPE), POINTER :: FACE
      INTEGER                  :: NFACE,COUNTER
      INTEGER,INTENT(IN) :: NFIL
      INTEGER,ALLOCATABLE,DIMENSION(:) :: FACE_IDENT
      INTEGER,ALLOCATABLE,DIMENSION(:) :: FACE_ATOM_IDENT
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: FACE_MIDPOINT
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: FACE_TRI1
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: FACE_TRI2
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: FACE_TRI3
      REAL(8),ALLOCATABLE,DIMENSION(:) :: FACE_AREA
      REAL(8),ALLOCATABLE,DIMENSION(:) :: FACE_Q
      REAL(8),ALLOCATABLE,DIMENSION(:) :: FACE_QM
      REAL(8),ALLOCATABLE,DIMENSION(:) :: FACE_FMEM
      INTEGER(4)                       :: NTASKS,THISTASK
      LOGICAL                          :: ON
!
!     CALL MPE$QUERY('NONE',NTASKS,THISTASK)
!     IF(THISTASK.EQ.1) THEN
       READ(NFIL)NFACE
       PRINT*,'NFACE READ ',NFACE
!     END IF
!     CALL MPE$BROADCAST('NONE',1,NFACE)
      
!
      ALLOCATE(FACE_IDENT(NFACE))
      ALLOCATE(FACE_ATOM_IDENT(NFACE))
      ALLOCATE(FACE_MIDPOINT(3,NFACE))
      ALLOCATE(FACE_TRI1(3,NFACE))
      ALLOCATE(FACE_TRI2(3,NFACE))
      ALLOCATE(FACE_TRI3(3,NFACE))
      ALLOCATE(FACE_AREA(NFACE))
      ALLOCATE(FACE_Q(NFACE))
      ALLOCATE(FACE_QM(NFACE))
      ALLOCATE(FACE_FMEM(NFACE))
!      
!     IF(THISTASK.EQ.1) THEN
        READ(NFIL)FACE_IDENT,FACE_ATOM_IDENT,FACE_MIDPOINT,&
         & FACE_TRI1,FACE_TRI2,FACE_TRI3,FACE_AREA,FACE_Q,FACE_QM,FACE_FMEM
!     END IF
      CALL MPE$BROADCAST('MONOMER',1,FACE_IDENT)
      CALL MPE$BROADCAST('MONOMER',1,FACE_ATOM_IDENT)
      CALL MPE$BROADCAST('MONOMER',1,FACE_MIDPOINT)
      CALL MPE$BROADCAST('MONOMER',1,FACE_TRI1)
      CALL MPE$BROADCAST('MONOMER',1,FACE_TRI2)
      CALL MPE$BROADCAST('MONOMER',1,FACE_TRI3)
      CALL MPE$BROADCAST('MONOMER',1,FACE_AREA)
      CALL MPE$BROADCAST('MONOMER',1,FACE_Q)
      CALL MPE$BROADCAST('MONOMER',1,FACE_QM)
      CALL MPE$BROADCAST('MONOMER',1,FACE_FMEM)
!
      DO COUNTER=1,NFACE
       CALL MAKEFACE(FACE,1)
       FACE%IDENT=FACE_IDENT(COUNTER)
       FACE%ATOM_IDENT=FACE_ATOM_IDENT(COUNTER)
       FACE%MIDPOINT(:)=FACE_MIDPOINT(:,COUNTER)
       FACE%TRI1(:)=FACE_TRI1(:,COUNTER)
       FACE%TRI2(:)=FACE_TRI2(:,COUNTER)
       FACE%TRI3(:)=FACE_TRI3(:,COUNTER)
       FACE%AREA=FACE_AREA(COUNTER)
       FACE%Q=FACE_Q(COUNTER)
       FACE%QM=FACE_QM(COUNTER)
       FACE%FMEM=FACE_FMEM(COUNTER)
      ENDDO
!
!
      DEALLOCATE(FACE_IDENT)
      DEALLOCATE(FACE_ATOM_IDENT)
      DEALLOCATE(FACE_MIDPOINT)
      DEALLOCATE(FACE_TRI1)
      DEALLOCATE(FACE_TRI2)
      DEALLOCATE(FACE_TRI3)
      DEALLOCATE(FACE_AREA)
      DEALLOCATE(FACE_Q)
      DEALLOCATE(FACE_QM)
      DEALLOCATE(FACE_FMEM)
!
      END SUBROUTINE CONTINUUM_READ
!
!     -------------------------------------------------------------------
!
      SUBROUTINE READ_TESSELATION(IAT,R)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      TYPE (FACETYPE), POINTER :: FACE,FIRSTFACE_HERE
      INTEGER,INTENT(IN) :: IAT
      REAL(8),INTENT(IN) :: R(3)
      INTEGER                  :: NFACE,NPOINT
      INTEGER                  :: COUNTER,I
      INTEGER                  :: FIRSTFACE_INDEX
      REAL(8),POINTER,DIMENSION(:,:) :: POINTS
      REAL(8)                   :: SIGMA
      INTEGER                  :: VERTEX(3),NFIL,NAT
      REAL(8)                   :: SURFACE,DISTANCE
      CHARACTER(8),ALLOCATABLE,DIMENSION(:) :: TESSELATION_NAME
      REAL(8),ALLOCATABLE,DIMENSION(:) :: RSOLV
!
      CALL ATOMLIST$NATOM(NAT)
      ALLOCATE(TESSELATION_NAME(NAT))
      ALLOCATE(RSOLV(NAT))
      CALL GET_SET_RSOLV('GET',NAT,RSOLV)
      CALL GET_SET_TESSNAME('GET',NAT,TESSELATION_NAME)
      CALL FILEHANDLER$UNIT(TESSELATION_NAME(IAT),NFIL)
      REWIND(NFIL)
      READ(NFIL,*)NPOINT
      ALLOCATE(POINTS(3,NPOINT))
      READ(NFIL,*)NFACE
      SIGMA=RSOLV(IAT)
      DEALLOCATE(RSOLV)
      SURFACE=(16.D0*DATAN(1.D0)*SIGMA**2)/DBLE(NFACE)
!
      DO COUNTER=1,NPOINT
       READ(NFIL,*)(POINTS(I,COUNTER),I=1,3)
      ENDDO
!
!     READ FACES AND ASSOCIATE WITH LINES, BUT DO NOT YET ASSOCIATE POINTS
!
      DO COUNTER=1,NFACE
       CALL MAKEFACE(FACE,IAT)
       IF (COUNTER == 1) THEN
        FIRSTFACE_INDEX=FACE%IDENT-1
        FIRSTFACE_HERE=>FACE
       ENDIF
       READ(NFIL,*)FACE%IDENT,VERTEX
       DO I=1,3
        FACE%MIDPOINT(I)=(POINTS(I,VERTEX(1))+POINTS(I,VERTEX(2))+&
          &POINTS(I,VERTEX(3)))/3.D0
       ENDDO
       FACE%MIDPOINT=FACE%MIDPOINT/DSQRT(SUM(FACE%MIDPOINT**2))
       DO I=1,3
        FACE%TRI1(I)=(POINTS(I,VERTEX(1))-FACE%MIDPOINT(I))*&
          &SIGMA
        FACE%TRI2(I)=(POINTS(I,VERTEX(2))-FACE%MIDPOINT(I))*&
          &SIGMA
        FACE%TRI3(I)=(POINTS(I,VERTEX(3))-FACE%MIDPOINT(I))*&
          &SIGMA
       ENDDO
       FACE%Q=0.D0
       FACE%AREA=SURFACE
       DO I=1,3
        FACE%MIDPOINT(I)=FACE%MIDPOINT(I)*SIGMA+R(I)
       ENDDO
       FACE%IDENT=FACE%IDENT+FIRSTFACE_INDEX
      ENDDO
      DEALLOCATE(POINTS)
      CALL FILEHANDLER$CLOSE(TESSELATION_NAME(IAT))
      DEALLOCATE(TESSELATION_NAME)
!
      END SUBROUTINE READ_TESSELATION
!
!     ---------------------------------------------------------------------
!
      SUBROUTINE STOP_NETCHARGES(STOP)
      IMPLICIT NONE
      INTEGER :: NFILO
      LOGICAL, INTENT(IN) :: STOP
      TYPE (FACETYPE),POINTER :: FACE
!
      IF (STOP) THEN
       CALL FILEHANDLER$UNIT('PROT',NFILO)
       WRITE(NFILO,*)'STOPPING MOTION OF MESH CHARGES !'
       FACE=>FIRSTFACE
       DO WHILE (ASSOCIATED(FACE))
        FACE%QM=FACE%Q
        FACE=>FACE%NEXT
       ENDDO
      ENDIF
!
      END SUBROUTINE STOP_NETCHARGES
!
!     ---------------------------------------------------------------------
!
      SUBROUTINE MIDPOINT_DISTANCE
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      REAL(8)                  :: DISTANCE,MINIMUM_DISTANCE
      TYPE (FACETYPE),POINTER :: FACE,COUNTERFACE
!
      MINIMUM_DISTANCE=1.D10
!
      FACE=>FIRSTFACE
      DO WHILE (ASSOCIATED(FACE))
       COUNTERFACE=>FACE%NEXT
       DO WHILE (ASSOCIATED(COUNTERFACE))
        IF (FACE%ATOM_IDENT == COUNTERFACE%ATOM_IDENT) THEN
         DISTANCE=DSQRT(SUM((FACE%MIDPOINT-COUNTERFACE%MIDPOINT)**2))
         IF (DISTANCE < MINIMUM_DISTANCE) MINIMUM_DISTANCE=DISTANCE
        ENDIF
        COUNTERFACE=>COUNTERFACE%NEXT
       ENDDO
       FACE=>FACE%NEXT
      ENDDO
!
      WRITE(*,*)'MINIMUM MIDPOINT DISTANCE IN SAME SPHERE ',&
        &MINIMUM_DISTANCE
      CALL GET_SET_SMALLESTMIDP('SET',MINIMUM_DISTANCE)
!
      END SUBROUTINE MIDPOINT_DISTANCE
!
!
!     =======================================================================
!
      FUNCTION FERMI_FUNCTION(R,R0) RESULT(FERMI)
      IMPLICIT NONE
      REAL(8) :: R,R0,FERMI
!
      IF (R > (R0-0.9D0)) THEN
       FERMI=(DEXP(-(R-R0+0.9D0)**48.D0))
      ELSE
       FERMI=1.D0
      ENDIF
!
      END FUNCTION FERMI_FUNCTION
!
!     =======================================================================
!
      FUNCTION DFERMI_DR(R,R0) RESULT(DFERMI)
      IMPLICIT NONE
      REAL(8) :: R,R0,DFERMI
!
      IF (R > (R0-0.9D0)) THEN
       DFERMI=-48.D0*(0.9D0-R0+R)**47.D0*(DEXP(-(R-R0+0.9D0)**48.D0))
      ELSE
       DFERMI=0.D0
      ENDIF
!
      END FUNCTION DFERMI_DR
!
!     =======================================================================
!
      SUBROUTINE FORCES_AND_ENERGY(FZO,MOVE_ATOMS,NAT,ATOM_R,NG,RC,QMAD,&
          &ECONT,PCONT,CFORCE,TWRITE)
!
!     ---- GET CALLS FROM CONTINUUM CONTROL MODULE ---
!
      USE CONTINUUM_CONTROL_MODULE
!
!     ---- NO IMPLICIT TYPES ----
!
      IMPLICIT NONE
!
!     ----- INHERITED VARIABLES -------
!
      LOGICAL, INTENT(IN)     :: MOVE_ATOMS,FZO,TWRITE
      INTEGER,INTENT(IN)      :: NAT
      INTEGER,INTENT(IN)      :: NG
      REAL(8),INTENT(OUT)      :: ECONT
      REAL(8),DIMENSION(3,NAT) :: CFORCE
      REAL(8),DIMENSION(3,NAT) :: ATOM_R
      REAL(8),DIMENSION(NG,NAT)   :: RC
      REAL(8),DIMENSION(NG,NAT)   :: PCONT
      REAL(8),DIMENSION(NG,NAT)   :: QMAD
!
!     ----- OTHER VARIABLES -----
!     ----- ALLOCATABLE VARIABLES ----
!
      TYPE (FACETYPE),POINTER :: FACE,COUNTERFACE
      REAL(8),POINTER,DIMENSION(:,:)   :: AFD !ATOM_FACE_DISTANCE
      REAL(8),POINTER,DIMENSION(:,:,:) :: AFV !ATOM_FACE_VECTOR
      REAL(8),POINTER,DIMENSION(:)     :: FOC !FORCE ON CHARGE
      REAL(8),POINTER,DIMENSION(:,:)   :: FERMI  !ATOM_FACE_FERMI
      REAL(8),POINTER,DIMENSION(:,:,:) :: DFERMI !ATOM_FACE_DFERMI
      REAL(8),POINTER,DIMENSION(:)     :: AREA  !FACE_AREA
      REAL(8),POINTER,DIMENSION(:)     :: FACE_CHARGE
      REAL(8),POINTER,DIMENSION(:)     :: FACE_CHARGE_SQUARE
      LOGICAL,POINTER,DIMENSION(:,:)  :: FBA  !FACE_BELONGSTO_ATOM
      LOGICAL,POINTER,DIMENSION(:)    :: IGNORE
      REAL(8),POINTER,DIMENSION(:)     :: ATOM_SIGMA
      REAL(8),POINTER,DIMENSION(:,:)   :: MID
      REAL(8),POINTER,DIMENSION(:,:)   :: ATOM_FORCE
      REAL(8),POINTER,DIMENSION(:)     :: BIGF !PRODUCT OF FERMI FUNCTIONS
      REAL(8),POINTER,DIMENSION(:,:,:)   :: NFE !QQ/(R-R)*BIGF(R)
      REAL(8),POINTER,DIMENSION(:,:,:) :: DBIGFDRI 
      REAL(8),POINTER,DIMENSION(:)     :: ATOMIC_SURFACE !SURFACE ASS. WITH ATOM
      INTEGER,POINTER,DIMENSION(:)    :: ABF !ATOM_BELONGSTO_FACE
!
!     ----- LOOP INDICES -----
!
      INTEGER :: AI,CAI,FI,CFI,VI,CCAI,IG
!
!     ----- NUMBER OF FACES ------
!
      INTEGER :: NUMBER_OF_FACES
!
!     ----- CONTRIBUTIONS TO THE ENERGY -----
!
      REAL(8)  :: INTER_TRIANGLE_ENERGY,ATOM_TRIANGLE_ENERGY,&
                &INTRA_TRIANGLE_ENERGY,HARDNESS_ENERGY,NETCHARGE,&
                &INSIDE_CHARGE,POSITIVE_INTEGRAL,NEGATIVE_INTEGRAL,&
                &SCALING_FACTOR,SURFACETENSION_ENERGY,SURFACE_AREA
!
!     ----- VARIOUS CONSTANTS -----
!
      REAL(8)  :: K1,K_TENSION,FERMI_CUTOFF
      REAL(8)  :: FORM_FACTOR=1.9D0  !FORM_FACTOR=1.44238D0
      REAL(8)  :: ERFNORM,GAUSS,ERRFUNC
!
!     ----- MISCELLANEOUS -----
!
      REAL(8)  :: F,DF,D,DIFF(3),CP,FF,DFF,FFMIN,T1,T2,T3,&
                &FERMI1,FERMI2,FERMI4,FERMI12,INSIDE_PLUS,&
                &INSIDE_MINUS,PRODJ,BCT1,BFT1,QQOVERD,SVAR,FVAR(3),&
                &FVAR1(3),T3D,DT1,FFACT,HFAC(3),TWOK2,DISTANCE
      LOGICAL :: SEAM
      REAL(8) :: ERFX
!
                 CALL TIMING$CLOCKON('CONT:FORCE/ENERGY INIT')
!
!     ----- INITIALIZE CONSTANTS -----
!
      K1=1.D1    !HARDNESS FOR HARDNESS_ENERGY
!     ----- THIS IS GODDARD'S VALUES, FITTED FOR HIS SAS
!      SURFACETENSION_ENERGY=0.001737D0
!      K_TENSION=2.2314D-6
!     ----- THIS IS FITTED TO R(C)=3.32AU AND R(H)=2.17AU
      SURFACETENSION_ENERGY=0.0018276D0
      K_TENSION=4.6647D-6
      ERFNORM=2.D0/SQRT(4.D0*DATAN(1.D0))
!
!     ----- COMPUTE SOME OTHERS  -----
!
      CALL GET_SET_SCALINGFACTOR('GET',SCALING_FACTOR)
      CALL GET_SET_SMALLESTMIDP('GET',FFMIN)
      FERMI_CUTOFF=0.8D0*FFMIN
!     ----- THIS WAS THE OLD VALUE, DESIGNED FOR A TRUE FERMI FUNCTION
!      FERMI_CUTOFF=0.8D0*FFMIN*(-DLOG(1.D-8))**(1.D0/12.D0)
      CALL GET_FACE_NUMBER(NUMBER_OF_FACES)
!
!     ------ WITH NUMBER_OF_FACES AND NAT, --------
!     ------ ALLOCATE ARRAYS ----------------------
!
      ALLOCATE(AFD(NAT,NUMBER_OF_FACES))
      ALLOCATE(FBA(NAT,NUMBER_OF_FACES))
      ALLOCATE(FOC(NUMBER_OF_FACES))
      ALLOCATE(ATOM_SIGMA(NAT))
      ALLOCATE(FERMI(NAT,NUMBER_OF_FACES))
      ALLOCATE(DFERMI(NAT,NAT,NUMBER_OF_FACES))
      ALLOCATE(AREA(NUMBER_OF_FACES))
      ALLOCATE(FACE_CHARGE(NUMBER_OF_FACES))
      ALLOCATE(FACE_CHARGE_SQUARE(NUMBER_OF_FACES))
      ALLOCATE(ATOM_FORCE(3,NAT))
      ALLOCATE(AFV(3,NAT,NUMBER_OF_FACES))
      ALLOCATE(ABF(NUMBER_OF_FACES))
      ALLOCATE(MID(3,NUMBER_OF_FACES))
      ALLOCATE(BIGF(NUMBER_OF_FACES))
      ALLOCATE(NFE(NG,NAT,NUMBER_OF_FACES))
      ALLOCATE(DBIGFDRI(3,NAT,NUMBER_OF_FACES))
      ALLOCATE(IGNORE(NUMBER_OF_FACES))
      ALLOCATE(ATOMIC_SURFACE(NAT))
!
!     ------ MAKE SURE ENERGIES ARE ZERO AT BEGINNING
!
      INTER_TRIANGLE_ENERGY=0.D0
      ATOM_TRIANGLE_ENERGY=0.D0
      INTRA_TRIANGLE_ENERGY=0.D0
      HARDNESS_ENERGY=0.D0
      NETCHARGE=0.D0
      INSIDE_CHARGE=0.D0
      POSITIVE_INTEGRAL=0.D0
      NEGATIVE_INTEGRAL=0.D0
      SURFACE_AREA=0.D0
!
!     ----- INITIALIZE SOME ARRAYS ----
!
      ALLOCATE(ATOM_SIGMA(NAT))
      CALL GET_SET_RSOLV('GET',NAT,ATOM_SIGMA)
      DO AI=1,NAT
!
!     ----- POTENTIAL ACTING ON THE NUCLEI ----
!
       PCONT(:,AI)=0.D0
!
!     ----- SURFACE AREA ASSOCIATED WITH ATOMS ----
!
       ATOMIC_SURFACE(AI)=0.D0
       FACE=>FIRSTFACE
       FI=1
       DO WHILE (ASSOCIATED(FACE))
!
!     ----- DECIDE WHICH FACES BELONG TO WHICH ATOMS
!
        IF (FACE%ATOM_IDENT == AI) THEN
         FBA(AI,FI)=.TRUE.
         ABF(FI)=AI
        ELSE
         FBA(AI,FI)=.FALSE.
        ENDIF
!
!     ----- COMPUTE VECTORS BETWEEN ATOMS AND FACE MIDPOINTES ----
!
        DO VI=1,3
         AFV(VI,AI,FI)=ATOM_R(VI,AI)-FACE%MIDPOINT(VI)
        ENDDO
!
!     ----- AND THE DISTANCES -----
!
        AFD(AI,FI)=DSQRT(AFV(1,AI,FI)**2+AFV(2,AI,FI)**2+&
          &AFV(3,AI,FI)**2)
!
!     ----- ERASE FERMI FUNCTION DERIVATIVES ----
!
        DO CAI=1,NAT
         DFERMI(CAI,AI,FI)=0.D0
        ENDDO
!
!     ----- FILL FERMI FUNCTIONS AND THEIR DERIVATIVES ----
!
        IF (FBA(AI,FI)) THEN
         FERMI(AI,FI)=1.D0
        ELSE
         FERMI(AI,FI)=1.D0-FERMI_FUNCTION(AFD(AI,FI),ATOM_SIGMA(AI))
         DFERMI(AI,AI,FI)=-DFERMI_DR(AFD(AI,FI),ATOM_SIGMA(AI))
        ENDIF
        FACE=>FACE%NEXT
        FI=FI+1
       ENDDO
      ENDDO
!
!     ----- SET "IGNORE" SWITCHES TO ZERO FOR ALL FACES, -----
!     ----- THEY'LL GET FILLED UP LATER IF "FZO" IS TRUE -----
!
      DO FI=1,NUMBER_OF_FACES
       IGNORE(FI)=.FALSE.
!
!     ----- COMPLETE THE DERIVATIVES OF THE FERMI FUNCTIONS ----
!
       DO AI=1,NAT
        DFERMI(ABF(FI),AI,FI)=-DFERMI(AI,AI,FI)
       ENDDO
      ENDDO
!
!
!     ----- CREATE THE SURFACE FUNCTION F ----
!
      DO FI=1,NUMBER_OF_FACES
       BIGF(FI)=1.D0
       VI=ABF(FI)
       DO AI=1,VI-1
        BIGF(FI)=BIGF(FI)*FERMI(AI,FI)
       ENDDO
       DO AI=VI+1,NAT
        BIGF(FI)=BIGF(FI)*FERMI(AI,FI)
       ENDDO
      ENDDO
!
!     ------ PUT AREAS AND CHARGES + THEIR SQUARES ON ARRAYS ----
!
      FACE=>FIRSTFACE
      FI=1
      DO WHILE (ASSOCIATED(FACE))
       AREA(FI)=FACE%AREA
       DO VI=1,3
        MID(VI,FI)=FACE%MIDPOINT(VI)
       ENDDO
!
!     ------ IF "FZO" IS TRUE, CRY OUT IF A BIG CHARGE IS ANNIHILATED ---
!
       IF (FZO .AND. (BIGF(FI) < 1.D-5)) THEN
        IF (DABS(FACE%Q) > 1.D-4) THEN
         WRITE(*,*)'FACE ',FI,' HAS FINITE CHARGE ',FACE%Q
        ENDIF
        IGNORE(FI)=.TRUE.
! NO LONGER NECESSARY
!        FACE%Q=0.D0
       ENDIF
       FACE_CHARGE(FI)=FACE%Q
       FACE_CHARGE_SQUARE(FI)=FACE_CHARGE(FI)*FACE_CHARGE(FI)
       FACE=>FACE%NEXT
       FI=FI+1
      ENDDO
!
!     ------ INTEGRATE ALL CHARGES ON NET -----
!
      INSIDE_PLUS=0.D0
      INSIDE_MINUS=0.D0
      FACELOOP4: DO FI=1,NUMBER_OF_FACES
       DO AI=1,NAT
        IF (AFD(AI,FI) < ATOM_SIGMA(AI) .AND. .NOT. FBA(AI,FI)) THEN
         IF (FACE_CHARGE(FI) > 0.D0) THEN
          INSIDE_PLUS=INSIDE_PLUS+FACE_CHARGE(FI)
         ELSE
          INSIDE_MINUS=INSIDE_MINUS+FACE_CHARGE(FI)
         ENDIF
         CYCLE FACELOOP4
        ENDIF
       ENDDO
      ENDDO FACELOOP4
!
!
!     ----- CALCULATE THE DERIVATIVE OF "F" WITH RESPECT TO ----
!     ----- NUCLEAR DISPLACEMENTS, AND BESIDES CALCULATE -----
!     ----- "NUCLEUS-FACE-ENERGY" FRAGMENT "NFE"   -----
!
      DO FI=1,NUMBER_OF_FACES
       DO AI=1,NAT
        DO IG=1,NG
         NFE(IG,AI,FI)=FACE_CHARGE(FI)*QMAD(IG,AI)/AFD(AI,FI)
        ENDDO
        IF (.NOT. FBA(AI,FI)) THEN
         IF (DABS(FERMI(AI,FI)) > 1.D-15) THEN
          T1=BIGF(FI)/FERMI(AI,FI)*(DFERMI(AI,AI,FI))/AFD(AI,FI)
         ELSE
          T1=0.D0
         ENDIF
         DO VI=1,3
          DBIGFDRI(VI,AI,FI)=T1*AFV(VI,AI,FI)
         ENDDO
        ELSE
         PRODJ=1.D0
         DO VI=1,3
          CAI=NAT
          DBIGFDRI(VI,AI,FI)=DFERMI(AI,CAI,FI)/AFD(CAI,FI)&
         & *AFV(VI,CAI,FI)
         ENDDO
!
!     ----- THIS IS SORT OF RECURSIVE ----
!
         OTHER_ATOMS: DO CAI=NAT,2,-1
          PRODJ=PRODJ*FERMI(CAI,FI)
          DO VI=1,3
           DBIGFDRI(VI,AI,FI)=DBIGFDRI(VI,AI,FI)*FERMI(CAI-1,FI)+PRODJ*&
          &(DFERMI(AI,CAI-1,FI)/AFD(CAI-1,FI)*AFV(VI,CAI-1,FI))
          ENDDO
         ENDDO OTHER_ATOMS
        ENDIF
       ENDDO
      ENDDO
!
                 CALL TIMING$CLOCKOFF('CONT:FORCE/ENERGY INIT')
!
!     ----------------------------------------------
!     ----------- NOW DO FORCES ON CHARGES ---------
!     ----------------------------------------------
!
                 CALL TIMING$CLOCKON('CONT:CHARGE FORCE 1')
!
!     ----- 1DIMENSIONAL LOOP OVER CHARGES -----
!
      CF1LOOP: DO FI=1,NUMBER_OF_FACES
       FOC(FI)=0.D0
!
!     ------ HARDNESS FORCES IN OVERLAP REGION -----
!
       FOC(FI)=FOC(FI)-K1*(1.D0-BIGF(FI))*FACE_CHARGE(FI)*2.D0
 
!     ------ HARDNESS ENERGY CONTRIBUTION IN OVERLAP REGION -----

       HARDNESS_ENERGY=HARDNESS_ENERGY+K1*&
         &(1.D0-BIGF(FI))*FACE_CHARGE(FI)**2
!
!     ------ DON'T RUN OVER OTHER ENERGY AND FORCE CONTRIBUTIONS ----
!     ------ IF IGNORE IS ON                                     ----
!
       IF (IGNORE(FI)) CYCLE CF1LOOP
!
!     ----- ADD UP TO SURFACE AREA -----
!
       SURFACE_AREA=SURFACE_AREA+BIGF(FI)*AREA(FI)
!
!     ------ INTEGRATE ALL CHARGES ON NET -------
!
       NETCHARGE=NETCHARGE+FACE_CHARGE(FI)
       IF (FACE_CHARGE(FI) > 0.D0) THEN
        POSITIVE_INTEGRAL=POSITIVE_INTEGRAL+FACE_CHARGE(FI)
       ELSE
        NEGATIVE_INTEGRAL=NEGATIVE_INTEGRAL+FACE_CHARGE(FI)
       ENDIF
!
!     ------ INTERACTION OF A FACE WITH ITSELF          -----
!     ------ FORM_FACTOR HAS YET TO BE FITTED; CAUTION! -----
!     ------ FOR THE TIME BEING FORMULA IS ONLY VALID FOR ---
!     ------ EQUILATERAL TRIANGLES                      -----
!
       FOC(FI)=FOC(FI)-FORM_FACTOR*AREA(FI)**(-0.5D0)*2.D0*&
               &FACE_CHARGE(FI)*SCALING_FACTOR
!
!     ------ INTERACTION WITH NUCLEAR CHARGES -----
!
       DO AI=1,NAT
! CAUTION CAUTION CAUTION
        DO IG=1,NG
          CALL LIB$ERFR8(AFD(AI,FI)/RC(IG,AI),ERFX)
          FOC(FI)=FOC(FI)-QMAD(IG,AI)*ERFX/AFD(AI,FI)*BIGF(FI)
        ENDDO
        IF (.NOT. FBA(AI,FI) .AND. (AFD(AI,FI) < ATOM_SIGMA(AI)).AND. &
            &(DABS(FACE_CHARGE(FI)) > DABS(INSIDE_CHARGE))) THEN
         INSIDE_CHARGE=FACE_CHARGE(FI)
        ENDIF

!       DO AI=1,NAT
!        FOC(FI)=FOC(FI)-QMAD(AI)/AFD(AI,FI)*BIGF(FI)
!        IF (.NOT. FBA(AI,FI) .AND. (AFD(AI,FI) < ATOM_SIGMA(AI)).AND. &
!            &(DABS(FACE_CHARGE(FI)) > DABS(INSIDE_CHARGE))) THEN
!         INSIDE_CHARGE=FACE_CHARGE(FI)
!        ENDIF
!
!     ------- DETERMINE SOLVENT ACCESSIBLE AREAS ON EACH ATOM -----
!
        IF (FBA(AI,FI)) THEN
         ATOMIC_SURFACE(AI)=ATOMIC_SURFACE(AI)+BIGF(FI)*AREA(FI)
        ENDIF
!
!     ------- DETERMINE POTENTIAL ACTING ON THE NUCLEUS -----
!
        DO IG=1,NG
         CALL LIB$ERFR8(AFD(AI,FI)/RC(IG,AI),ERFX)
         PCONT(IG,AI)=PCONT(IG,AI)+FACE_CHARGE(FI)*ERFX/AFD(AI,FI)*BIGF(FI)
        ENDDO
       ENDDO
!
!     ------- SELF INTERACTION ENERGY OF TRIANGLES -----
!
       INTRA_TRIANGLE_ENERGY=INTRA_TRIANGLE_ENERGY+FORM_FACTOR*&
        &FACE_CHARGE(FI)**2*AREA(FI)**(-0.5D0)
!
!     ------- SURFACE TENSION ENERGY            --------
!
       SURFACETENSION_ENERGY=SURFACETENSION_ENERGY+K_TENSION*&
        &AREA(FI)*BIGF(FI)
!
      ENDDO CF1LOOP
!
                 CALL TIMING$CLOCKOFF('CONT:CHARGE FORCE 1')
!
!     --- JUST MAKE SURE ATOMIC FORCES ARE ERASED
!
      DO AI=1,NAT
       DO VI=1,3
        ATOM_FORCE(VI,AI)=0.D0
       ENDDO
      ENDDO
!
!     ------ INTERACTION WITH OTHER FACES -----
!
                 CALL TIMING$CLOCKON('CONT:CHARGE FORCE 2')
!
!     ----- 2DIMENSIONAL LOOP OVER ALL FACES/FACES ---                             
!
      OUTERLOOP: DO FI=1,NUMBER_OF_FACES
!
!     ----- THIS CRITERION HAS TO BE CHECKED FOR ALL ---
!     ----- NEW ENERGY CONTRIBUTIONS; MIGHT NOT BE TRUE ---
!
       IF (IGNORE(FI)) CYCLE OUTERLOOP
       INNERLOOP: DO CFI=FI+1,NUMBER_OF_FACES
!
!     ----- THIS, TOO!!  ----
!
        IF (IGNORE(CFI)) CYCLE INNERLOOP
        AI=ABF(FI)
        CAI=ABF(CFI)
!
!     ----- SCALING FACTOR ACCOUNTS FOR FINITE DIELECTRIC ---
!     ----- CONSTANT, RIGHT NOW IN THE TRUONGH FASHION, WHERE ---
!     ----- THE SELF INTERACTION OF THE CHARGED SURFACE IS ----
!     ----- INCREASED ----
!
        T3=BIGF(FI)*BIGF(CFI)*SCALING_FACTOR
        DO VI=1,3
         DIFF(VI)=MID(VI,FI)-MID(VI,CFI)
        ENDDO
        DISTANCE=DSQRT(DIFF(1)*DIFF(1)+DIFF(2)*DIFF(2)+DIFF(3)*DIFF(3))
!
!       ----- UPPER LIMIT FOR INTERACTION ENERGY -----
!
        IF (AI /= CAI .AND. DISTANCE <= FERMI_CUTOFF) THEN
         SEAM=.TRUE.
         DISTANCE=FERMI_CUTOFF
        ELSE
         SEAM=.FALSE.
        ENDIF
!
        D=1.D0/DISTANCE
        T3D=T3*D
        CP=FACE_CHARGE(FI)*FACE_CHARGE(CFI)
        QQOVERD=CP*D
!
!     ----- NORMAL SURFACE INTERACTION ENERGY
!
        INTER_TRIANGLE_ENERGY=INTER_TRIANGLE_ENERGY+CP*T3D
!
!     ----- NORMAL SURFACE INTERACTION POTENTIAL ---
!
        FOC(FI)= FOC(FI)- FACE_CHARGE(CFI)*T3D
        FOC(CFI)=FOC(CFI)-FACE_CHARGE(FI)*T3D
!
!     ----- NOW SET TO WORK ON FORCES ON ATOMS ----
!     ----- WHICH DEPEND ON THE INTERACTION OF THE SURFACE ----
!     ----- WITH ITSELF -----
!
        IF (MOVE_ATOMS) THEN
!
!       ----- FERMI FUNCTION BETWEEN TRIANGLES HAS NO FORCE ----
!       ----- ON ATOMS IF DISTANCE TOO LARGE               -----
!
         BFT1=BIGF(FI)*SCALING_FACTOR
         BCT1=BIGF(CFI)*SCALING_FACTOR
!
!       ----- IF THE CHARGES ARE ON THE SEAM, THERE IS NO ----
!       ----- DERIVATIVE OF ENERGY WITH RESPECT TO THE    ----
!       ----- DISTANCE BETWEEN THEM                       ----
!
         IF (SEAM) THEN
          SVAR=0.D0
         ELSE
          SVAR=T3D*D
         ENDIF
!
         DO VI=1,3
          FVAR(VI)=DIFF(VI)*SVAR
         ENDDO
         DO CCAI=1,NAT
          DO VI=1,3
           FVAR1(VI)=DBIGFDRI(VI,CCAI,FI)*BCT1+&
                    &BFT1*DBIGFDRI(VI,CCAI,CFI)
          ENDDO
!
!       ---- COMPUTE FORCE ON ATOM IF:                          ----
!       ---- NEITHER OF THE SURFACE CHARGES ARE NOT ON THE ATOM ----
!       ---- OR BOTH OF THE SURFACE CHARGES ARE ON THE ATOM     ----
!       ---- IN BOTH CASES THERE IS NO DERIVATIVE WITH RESPECT  ----
!       ---- TO THE DISTANCE BETWEEN THE CHARGES
!
          IF (CCAI /= AI .AND. CCAI /= CAI .OR. &
             &CCAI == AI .AND. CCAI == CAI) THEN
           DO VI=1,3
            ATOM_FORCE(VI,CCAI)=ATOM_FORCE(VI,CCAI)-QQOVERD*FVAR1(VI)
           ENDDO
          ELSE
!
!       ----  NOW, COMPUTE THE FORCE ON THE ATOM IF ONE OF THE ----
!       ----  CHARGES SITS ON THIS ATOM. IN THIS CASE, THERE   ----
!       ----  ARE DERIVATIVES WITH RESPECT TO THE DISTANCE AS  ----
!       ----  WELL AS TO BIGF                                  ----
!
           IF (CCAI == AI .AND. CCAI /= CAI) THEN
            DO VI=1,3
             ATOM_FORCE(VI,CCAI)=ATOM_FORCE(VI,CCAI)+QQOVERD*&
            &  (FVAR(VI)-FVAR1(VI))
            ENDDO
           ELSE
            DO VI=1,3
             ATOM_FORCE(VI,CCAI)=ATOM_FORCE(VI,CCAI)+QQOVERD*&
            &  (-FVAR(VI)-FVAR1(VI))
            ENDDO
           ENDIF
          ENDIF 
         ENDDO
        ENDIF
       ENDDO INNERLOOP
      ENDDO OUTERLOOP
!
!    ----- AFTER THE BATTLE'S OVER, SET SURFACE FORCES IN ----
!    ----- STRUCTURES ----
!
      FACE=>FIRSTFACE
      FI=1
      DO WHILE (ASSOCIATED(FACE))
! NO LONGER NECESSARY
!       IF (IGNORE(FI)) THEN
!        FACE%FQ=0.D0
!       ELSE
        FACE%FQ=FOC(FI)
!       ENDIF
       FACE=>FACE%NEXT
       FI=FI+1
      ENDDO
!
                 CALL TIMING$CLOCKOFF('CONT:CHARGE FORCE 2')
!
!     ----------------------------------------------
!     ----------- NOW DO FORCES ON NUCLEI ----------
!     ----------------------------------------------
!
!     ----- GET FORCES ACTING BETWEEN NUCLEUS AND FACES ----
!
                 CALL TIMING$CLOCKON('CONT:NUC FORCE/FACES')
!
      DO AI=1,NAT
       NFACELOOP: DO FI=1,NUMBER_OF_FACES
        DO IG=1,NG
         CALL LIB$ERFR8(AFD(AI,FI)/RC(IG,AI),ERFX)
         ATOM_TRIANGLE_ENERGY=ATOM_TRIANGLE_ENERGY+NFE(IG,AI,FI)*BIGF(FI)*ERFX
        ENDDO
        IF (.NOT. MOVE_ATOMS) CYCLE NFACELOOP
!
!     ---- FORCE DUE TO HARDNESS
!
        DO VI=1,3
         ATOM_FORCE(VI,AI)=ATOM_FORCE(VI,AI)+&
          &K1*FACE_CHARGE(FI)**2*DBIGFDRI(VI,AI,FI)
        ENDDO
        IF (IGNORE(FI)) CYCLE NFACELOOP
!
!     ---- FORCE DUE TO SURFACETENSION
!
        DO VI=1,3
         ATOM_FORCE(VI,AI)=ATOM_FORCE(VI,AI)-&
          &AREA(FI)*K_TENSION*DBIGFDRI(VI,AI,FI)
        ENDDO
!
!     ---- END FORCE OF HARDNESS AND SURFACE TENSION
!
        LOOP1: DO CAI=1,NAT
         IF (FBA(CAI,FI)) THEN
          IF (.NOT. FBA(AI,FI)) THEN
           DO IG=1,NG
            CALL LIB$ERFR8(AFD(AI,FI)/RC(IG,AI),ERRFUNC)
            GAUSS=ERFNORM*EXP(-(AFD(AI,FI)/RC(IG,AI))**2)
            DO VI=1,3
             ATOM_FORCE(VI,CAI)=ATOM_FORCE(VI,CAI)-&
             NFE(IG,AI,FI)*(AFV(VI,AI,FI)*BIGF(FI)* &
             &  (ERRFUNC/AFD(AI,FI)**2 - GAUSS/(AFD(AI,FI)*RC(IG,AI))) + &
             &  DBIGFDRI(VI,CAI,FI)*ERRFUNC)
            ENDDO
           ENDDO
           CYCLE LOOP1
          ELSE
           DO VI=1,3
            DO IG=1,NG
             CALL LIB$ERFR8(AFD(AI,FI)/RC(IG,AI),ERFX)
             ATOM_FORCE(VI,CAI)=ATOM_FORCE(VI,CAI)-NFE(IG,AI,FI)*ERFX &
      &                        *DBIGFDRI(VI,CAI,FI)
            ENDDO
           ENDDO
           CYCLE LOOP1
          ENDIF
         ELSE
          IF (AI == CAI) THEN
           DO IG=1,NG
            CALL LIB$ERFR8(AFD(AI,FI)/RC(IG,AI),ERRFUNC)
            GAUSS=ERFNORM*EXP(-(AFD(AI,FI)/RC(IG,AI))**2)
            DO VI=1,3
             ATOM_FORCE(VI,CAI)=ATOM_FORCE(VI,CAI)-&
             NFE(IG,AI,FI)*(AFV(VI,AI,FI)*BIGF(FI)* &
             &  (-ERRFUNC/AFD(AI,FI)**2 + GAUSS/(AFD(AI,FI)*RC(IG,AI))) + &
             &  DBIGFDRI(VI,CAI,FI)*ERRFUNC)
            ENDDO
           ENDDO
           CYCLE LOOP1
          ELSE
           DO VI=1,3
            DO IG=1,NG
             CALL LIB$ERFR8(AFD(AI,FI)/RC(IG,AI),ERFX)
             ATOM_FORCE(VI,CAI)=ATOM_FORCE(VI,CAI)-NFE(IG,AI,FI)*ERFX &
       &                       *DBIGFDRI(VI,CAI,FI)
            ENDDO
           ENDDO
           CYCLE LOOP1
          ENDIF
         ENDIF
        ENDDO LOOP1
       ENDDO NFACELOOP
      ENDDO
                 CALL TIMING$CLOCKOFF('CONT:NUC FORCE/FACES')
!
!     -------- RETURN FORCES ON NUCLEI IN CFORCE
!
      DO AI=1,NAT
       DO VI=1,3
        CFORCE(VI,AI)=ATOM_FORCE(VI,AI)
       ENDDO
      ENDDO
!
!
!     ----- ACCOUNT FOR FINITE DIELECTRIC IN SELF INTERACTION ----
!     ----- OF SURFACE TRIANGLES -----
!
      INTRA_TRIANGLE_ENERGY=INTRA_TRIANGLE_ENERGY*SCALING_FACTOR
      ECONT=INTER_TRIANGLE_ENERGY+&
          &INTRA_TRIANGLE_ENERGY+&
          &ATOM_TRIANGLE_ENERGY+&
          &HARDNESS_ENERGY+&
          &SURFACETENSION_ENERGY
!
      IF (TWRITE) THEN
!     ---- STORE ACCESSIBLE SURFACE IN GLOBAL VARIABLE ---
!
       CALL GET_SET_ACCSURFACE('SET',NAT,ATOMIC_SURFACE)
!
!     ----- SET ENERGY LISTS FOR PROTOCOL -----
!
       CALL ENERGYLIST$SET('INTER-TRIANGLE-POTENTIAL',&
         &INTER_TRIANGLE_ENERGY)
       CALL ENERGYLIST$SET('INTRA-TRIANGLE-POTENTIAL',&
         &INTRA_TRIANGLE_ENERGY)
       CALL ENERGYLIST$SET('ION-TRIANGLE-POTENTIAL',&
         &ATOM_TRIANGLE_ENERGY)
       CALL ENERGYLIST$SET('CAVITY-HARDNESS-POTENTIAL',&
         &HARDNESS_ENERGY)
       CALL ENERGYLIST$SET('SURFACETENSION-POTENTIAL',&
         &SURFACETENSION_ENERGY)
       CALL ENERGYLIST$SET('TOTAL-SURFACE-POTENTIAL',ECONT)
!       CALL ENERGYLIST$ADD('TOTAL ENERGY',ECONT)
!
!     ------ SET CHARGE INTEGRALS ON INTERNAL LIST ----
!
       CALL SET_CHARGE(NETCHARGE,INSIDE_CHARGE,NEGATIVE_INTEGRAL,&
         &POSITIVE_INTEGRAL,INSIDE_PLUS,INSIDE_MINUS)
!
!     ------ SET SURFACE AREA ON LIST -------
!
       CALL GET_SET_SURFACE_AREA(.TRUE.,SURFACE_AREA)
      ENDIF
!
!     ----- DEALLOCATE ALL TEMPORARY ARRAYS ----
!
      DEALLOCATE(AFD)
      DEALLOCATE(FBA)
      DEALLOCATE(FOC)
      DEALLOCATE(ATOM_SIGMA)
      DEALLOCATE(FERMI)
      DEALLOCATE(DFERMI)
      DEALLOCATE(AREA)
      DEALLOCATE(FACE_CHARGE)
      DEALLOCATE(FACE_CHARGE_SQUARE)
      DEALLOCATE(ABF)
      DEALLOCATE(ATOM_FORCE)
      DEALLOCATE(AFV)
      DEALLOCATE(MID)
      DEALLOCATE(BIGF)
      DEALLOCATE(NFE)
      DEALLOCATE(DBIGFDRI)
      DEALLOCATE(IGNORE)
      DEALLOCATE(ATOMIC_SURFACE)
!
      END SUBROUTINE FORCES_AND_ENERGY
!
      END MODULE NET_MODULE
!
!     ===============================================================
!     =======                             ===========================
!     ======= MAIN INTERFACING  ROUTINES FOR PAW_CONTINUUM ==========
!     =======                             ===========================
!     ===============================================================
!
!
!     SUBROUTINE CONTINUUM$SETC(MOVE_ATOMS,TCONTIN,TSTARTC,TMOVEC,TFZO,&
!     & TSTOPC,TAUTOC,MQ,EPSILON,ANNER1,ANNER2,SANNR1,SANNR2)
!      USE CONTINUUM_CONTROL_MODULE
!
!      IMPLICIT NONE
!      LOGICAL, INTENT(IN) :: MOVE_ATOMS,TCONTIN,TSTARTC,TMOVEC,&
!                           & TFZO,TSTOPC,TAUTOC
!      REAL(8), INTENT(IN)  :: MQ,ANNER1,ANNER2,SANNR1,SANNR2,EPSILON
!
!      CALL SET_CONTINUUM_CONTROLS(MOVE_ATOMS,TCONTIN,TSTARTC,TMOVEC,TFZO,&
!        &TSTOPC,TAUTOC,MQ,EPSILON,ANNER1,ANNER2,SANNR1,SANNR2)
!
!      END SUBROUTINE CONTINUUM$SETC
!
!     =======================================================================
!
!      SUBROUTINE CONTINUUM$WRITE(NAT,R0)
!      USE CONTINUUM_CONTROL_MODULE
!      USE NET_MODULE
!      IMPLICIT NONE
!      LOGICAL :: ON_FLAG
!      INTEGER,INTENT(IN) :: NAT
!      INTEGER :: NFIL
!      REAL(8),DIMENSION(3,NAT) :: R0
!
!      CALL GET_SET_ON('GET',ON_FLAG)
!      IF (.NOT. ON_FLAG) RETURN
!      CALL FILEHANDLER$UNIT('CONTINUUM_RESTART',NFIL)
!      REWIND(NFIL)
!
!      CALL WRITE_NET(NFIL)
!
!      CALL FILEHANDLER$CLOSE('CONTINUUM_RESTART')
!      CALL NET_REPORT(NAT,R0)
!
!      END SUBROUTINE CONTINUUM$WRITE
!
!     =======================================================================
!
      SUBROUTINE CONTINUUM$INITIALIZE
      USE CONTINUUM_CONTROL_MODULE
      USE NET_MODULE
      IMPLICIT NONE
      LOGICAL :: RESTART,STOP_FLAG,ON_FLAG
      INTEGER :: NAT,NFIL
      REAL(8),ALLOCATABLE,DIMENSION(:,:) :: R
      INTEGER :: I,IAT
!
      CALL GET_SET_ON('GET',ON_FLAG)
      IF (.NOT. ON_FLAG) RETURN
      CALL ATOMLIST$NATOM(NAT)
      ALLOCATE(R(3,NAT))
      CALL ATOMLIST$GETR8A('R(0)',0,3*NAT,R)
      CALL GET_SET_RESTART('GET',RESTART)
      IF (.NOT. RESTART) THEN
       DO IAT=1,NAT
        CALL READ_TESSELATION(IAT,R(1,IAT))
       ENDDO
      ENDIF
      DEALLOCATE(R)
!
      CALL MIDPOINT_DISTANCE
!
      CALL GET_SET_STOPNETCHARGES('GET',STOP_FLAG)
      CALL STOP_NETCHARGES(STOP_FLAG)
      CALL REPORT_CONTINUUM_CONTROLS
      CALL NET_REPORT(NAT,R)
!
      END SUBROUTINE CONTINUUM$INITIALIZE
!
!     =======================================================================
!
      SUBROUTINE CONTINUUM$PROPAGATE(NAT,R0,NG,RC,QMAD,ECONT,PCONT,CFORCE)
      USE CONTINUUM_CONTROL_MODULE
      USE NET_MODULE
      IMPLICIT NONE
      TYPE (FACETYPE),POINTER :: FACE
      INTEGER,INTENT(IN)      :: NAT,NG
      REAL(8),INTENT(OUT)         :: ECONT
      REAL(8),DIMENSION(3,NAT)    :: CFORCE
      REAL(8),DIMENSION(3,NAT)    :: CFORCEMEM,CFORCEX
      REAL(8),DIMENSION(NG,NAT)   :: RC
      REAL(8),DIMENSION(NG,NAT)   :: PCONT
      REAL(8),DIMENSION(NG,NAT)   :: PCONTMEM,PCONTX
      REAL(8),DIMENSION(NG,NAT)   :: QMAD
      REAL(8),DIMENSION(3,NAT)    :: R0
      REAL(8),ALLOCATABLE,DIMENSION(:) :: QV
      INTEGER :: IAT,I,NFACE,FI,MULTIPLE,J,K,L
      LOGICAL :: MOVE_ATOMS,FORCE_ZERO_OVERLAP,ON_FLAG,MOVE_NETCHARGES,&
                &THERMOSTAT,DUMMY
      REAL(8)  :: KINETIC_ENERGY,TIMESTEP,CHARGE_MASSDENSITY,&
        &CHARGE_FRICTION,SOME_VARIABLE,ETOT,DELT=1.D-8,E1,E2
      LOGICAL,SAVE :: TFIRST=.TRUE.,TVAF=.FALSE.,TNUMERICAL=.FALSE.
      LOGICAL :: RESTART
!
      IF (TFIRST) THEN
       CALL CONTINUUM$INITIALIZE
       IF (TVAF) OPEN(88,FILE='QVAF.OUT',FORM='UNFORMATTED')
      ENDIF
!
      ECONT=0.D0
      PCONT(:,:)=0.D0
      PCONTMEM(:,:)=0.D0
      CFORCE(:,:)=0.D0
      CFORCEMEM(:,:)=0.D0
!
      CALL GET_SET_ON('GET',ON_FLAG)
      IF (.NOT. ON_FLAG) RETURN
                               CALL TRACE$PUSH('CONTINUUM$PROPAGATE')
!
      CALL GET_SET_MULTIPLE('GET',MULTIPLE)
      CALL GET_SET_CHARGEFRICTION('GET',CHARGE_FRICTION)
      CALL GET_SET_TIMESTEP('GET',TIMESTEP)
      TIMESTEP=TIMESTEP/DBLE(MULTIPLE)
      CALL GET_SET_SURFACEMASS('GET',CHARGE_MASSDENSITY)
      CALL GET_SET_FZO('GET',FORCE_ZERO_OVERLAP)
      CALL GET_SET_MOVEATOMS('GET',MOVE_ATOMS)
!
!     ==== NO MULTIPLE TIMESTEPS
!
      IF (MULTIPLE == 1) THEN
!
       IF (TVAF) THEN
        CALL GET_FACE_NUMBER(NFACE)
        ALLOCATE(QV(NFACE))
       ENDIF
!
       CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
           &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
!
       IF (TNUMERICAL) THEN
        CALL NUMERICAL_DERIVATIVES
        STOP 'AFTER COMPLETING NUMERICAL DERIVATIVES!'
       ENDIF
!
!      ===== PROPAGATE CHARGES WITH VERLET
!
       CALL GET_SET_MOVENETCHARGES('GET',MOVE_NETCHARGES)
!
!      ----- LOOK UP WHETHER NOSE THERMOSTAT ACTIVE----
!
       CALL GET_THERMOSTAT(THERMOSTAT,DUMMY,SOME_VARIABLE,SOME_VARIABLE)
!
       IF (THERMOSTAT) THEN
!
!      ----- PROPAGATE FOR THE FIRST TIME WITHOUT FRICTION----
!
        CHARGE_FRICTION=0.D0
        CALL PROPAGATE
!
!       ------ CALL NOSE THERMOSTAT TO GET CHARGE_FRICTION -----
!
        CALL CONTINUUM$NOSE_THERMOSTAT(KINETIC_ENERGY,CHARGE_FRICTION)
       ENDIF
!
!      ------ PROPAGATE FOR THE SECOND TIME WITH THE CORRECT CHARGE_FRICTION ---
!
       CALL PROPAGATE
!
       CALL ENERGYLIST$SET('SURFACE Q EKIN',KINETIC_ENERGY)
       CALL ENERGYLIST$ADD('CONSTANT ENERGY',KINETIC_ENERGY)
!
!     ===== SWITCH CHARGES 
!
       FACE=>FIRSTFACE
       DO WHILE (ASSOCIATED(FACE))
         FACE%QM=FACE%Q
         FACE%Q=FACE%QP
         FACE=>FACE%NEXT
       ENDDO
       IF (TVAF) THEN
        WRITE(88)(QV(FI),FI=1,NFACE)
       ENDIF
!
      ELSE
!
!     ===========================================
!     ======== DO MULTIPLE TIMESTEPS HERE =======
!     ======== FIRST HALF OF CYCLE        =======
!     ===========================================
!
       CALL GET_SET_RESTART('GET',RESTART)
       FIRST_HALF: DO I=1,MULTIPLE/2
!
        IF (TFIRST .AND. (.NOT. RESTART)) THEN
         FACE=>FIRSTFACE
         DO WHILE (ASSOCIATED(FACE))
          FACE%FMEM=0.D0
          FACE=>FACE%NEXT
         ENDDO
         EXIT
        ENDIF
!
        CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
           &NG,RC,QMAD,ECONT,PCONT,CFORCE,.FALSE.)
!
!       ---- ADD MEMORY FORCE ON CHARGES ----
!       ---- AND STORE MEMORY FORCES ON NUCLEI AND WAVEFUNCTION -----
!
        IF (I == 1) THEN 
         FACE=>FIRSTFACE
         DO WHILE (ASSOCIATED(FACE))
          FACE%FQ=(FACE%FQ+FACE%FMEM)/2.D0
          FACE=>FACE%NEXT
         ENDDO
         CFORCEMEM=CFORCE
         PCONTMEM=PCONT
        ENDIF
!
!       ===== PROPAGATE CHARGES WITH VERLET
!
        CALL GET_SET_MOVENETCHARGES('GET',MOVE_NETCHARGES)
!
!       ----- LOOK UP WHETHER NOSE THERMOSTAT ACTIVE----
!
        CALL GET_THERMOSTAT(THERMOSTAT,DUMMY,SOME_VARIABLE,SOME_VARIABLE)
!
        IF (THERMOSTAT) THEN
!
!       ----- PROPAGATE FOR THE FIRST TIME WITHOUT FRICTION----
!
         CHARGE_FRICTION=0.D0
         CALL PROPAGATE
!
!        ------ CALL NOSE THERMOSTAT TO GET CHARGE_FRICTION -----
!
         CALL CONTINUUM$NOSE_THERMOSTAT(KINETIC_ENERGY,CHARGE_FRICTION)
        ENDIF
!
!      ------ PROPAGATE FOR THE SECOND TIME WITH THE CORRECT CHARGE_FRICTION ---
!
        CALL PROPAGATE
!
!      ===== SWITCH CHARGES 
!
        FACE=>FIRSTFACE
        DO WHILE (ASSOCIATED(FACE))
          FACE%QM=FACE%Q
          FACE%Q=FACE%QP
          FACE=>FACE%NEXT
        ENDDO
       ENDDO FIRST_HALF
!
!      ============= SECOND HALF OF CYCLE  ============
!
       SECOND_HALF: DO I=1,MULTIPLE/2
!
        IF (I == 1) THEN
         CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
           &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
        ELSE
         CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
           &NG,RC,QMAD,ECONT,PCONT,CFORCE,.FALSE.)
        ENDIF
!
!
!       ===== PROPAGATE CHARGES WITH VERLET
!
        CALL GET_SET_MOVENETCHARGES('GET',MOVE_NETCHARGES)
!
!       ----- LOOK UP WHETHER NOSE THERMOSTAT ACTIVE----
!
        CALL GET_THERMOSTAT(THERMOSTAT,DUMMY,SOME_VARIABLE,SOME_VARIABLE)
!
        IF (THERMOSTAT) THEN
!
!       ----- PROPAGATE FOR THE FIRST TIME WITHOUT FRICTION----
!
         CHARGE_FRICTION=0.D0
!
         CALL PROPAGATE
!
!        ------ CALL NOSE THERMOSTAT TO GET CHARGE_FRICTION -----
!
         CALL CONTINUUM$NOSE_THERMOSTAT(KINETIC_ENERGY,CHARGE_FRICTION)
        ENDIF
!
!      ------ PROPAGATE FOR THE SECOND TIME WITH THE CORRECT CHARGE_FRICTION ---
!
        CALL PROPAGATE
!
        IF (I == 1) THEN
         CALL ENERGYLIST$SET('SURFACE Q EKIN',KINETIC_ENERGY)
        ENDIF
!
!      ===== SWITCH CHARGES 
!
        FACE=>FIRSTFACE
        DO WHILE (ASSOCIATED(FACE))
          FACE%QM=FACE%Q
          FACE%Q=FACE%QP
          FACE=>FACE%NEXT
        ENDDO
       ENDDO SECOND_HALF
!
!     ===== GET FINAL FORCES AND POTENTIAL ON NUCLEI
!
       CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
         &NG,RC,QMAD,ECONT,PCONT,CFORCE,.FALSE.)
!
!
!      ===== STORE MEMORY FORCE ON CHARGES ----
!
       FACE=>FIRSTFACE
       DO WHILE (ASSOCIATED(FACE))
        FACE%FMEM=FACE%FQ
        FACE=>FACE%NEXT
       ENDDO
!
       IF ((.NOT. TFIRST) .OR. RESTART) THEN
        PCONT=(PCONT+PCONTMEM)/2.D0
        CFORCE=(CFORCE+CFORCEMEM)/2.D0
       ENDIF
      ENDIF
      CALL ENERGYLIST$ADD('CONSTANT ENERGY',KINETIC_ENERGY)
      TFIRST=.FALSE.
!
                          CALL TRACE$POP
      CONTAINS
!     --------------------------------------------
      SUBROUTINE PROPAGATE
!
      KINETIC_ENERGY=0.D0
      FI=1
      FACE=>FIRSTFACE
      DO WHILE (ASSOCIATED(FACE))
       IF (MOVE_NETCHARGES) THEN
        FACE%QP=(2.D0*FACE%Q-(1.D0-CHARGE_FRICTION)*FACE%QM+&
        &(FACE%FQ)/(CHARGE_MASSDENSITY)*TIMESTEP**2)/&
        &(1.D0+CHARGE_FRICTION)
        KINETIC_ENERGY=KINETIC_ENERGY+((FACE%QP-FACE%QM)/&
          &(2.D0*TIMESTEP))**2*CHARGE_MASSDENSITY*0.5D0
       ELSE
        FACE%QP=FACE%Q
       ENDIF
       IF (TVAF) QV(FI)=(FACE%QP-FACE%QM)/(2.D0*TIMESTEP)
       FACE=>FACE%NEXT
       FI=FI+1
      ENDDO
!
      END SUBROUTINE PROPAGATE
!
!     --------------------------------------------
!
      SUBROUTINE NUMERICAL_DERIVATIVES
!
!     ==== NUMERICAL FORCES ON NUCLEI ======
!
      WRITE(*,*)'ANALYTICAL FORCES ON NUCLEI:'
      DO I=1,NAT
       WRITE(*,FMT='(3(1X,F15.9))')CFORCE(1:3,I)
      ENDDO
      CFORCEX=CFORCE
      DO I=1,NAT
!      WRITE(*,*)'ATOM(',I,')'
       DO J=1,3
!       WRITE(*,*)'XYZ(',J,')'
!
        R0(J,I)=R0(J,I)+DELT
        FACE=>FIRSTFACE
        DO WHILE (ASSOCIATED(FACE))
         IF (FACE%ATOM_IDENT == I) THEN
          FACE%MIDPOINT(J)=FACE%MIDPOINT(J)+DELT
         ENDIF
         FACE=>FACE%NEXT
        ENDDO
!
        CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
          &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
        E2=ECONT
!
        R0(J,I)=R0(J,I)-2.D0*DELT
        FACE=>FIRSTFACE
        DO WHILE (ASSOCIATED(FACE))
         IF (FACE%ATOM_IDENT == I) THEN
          FACE%MIDPOINT(J)=FACE%MIDPOINT(J)-2.D0*DELT
         ENDIF
         FACE=>FACE%NEXT
        ENDDO
!
        CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
          &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
        E1=ECONT
!
        CFORCEMEM(J,I)=-(E2-E1)/(2.D0*DELT)
!
        R0(J,I)=R0(J,I)+DELT
        FACE=>FIRSTFACE
        DO WHILE (ASSOCIATED(FACE))
         IF (FACE%ATOM_IDENT == I) THEN
          FACE%MIDPOINT(J)=FACE%MIDPOINT(J)+DELT
         ENDIF
         FACE=>FACE%NEXT
        ENDDO
!
       ENDDO
      ENDDO
      WRITE(*,*)'NUMERICAL FORCES ON NUCLEI:'
      DO I=1,NAT
       WRITE(*,FMT='(3(1X,F15.9))')CFORCEMEM(1:3,I)
      ENDDO
      WRITE(*,*)'(NUMERICAL-ANALYTICAL)/ANALYTICAL'
      DO I=1,NAT
       WRITE(*,FMT='(3(1X,F15.9))')(CFORCEMEM(1:3,I)-CFORCEX(1:3,I))/CFORCEX(1:3,I)
      ENDDO
!
!     ==== NUMERICAL FORCES ON SHIELDING GAUSSIANS ======
!
      CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
         &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
!
      WRITE(*,*)
      WRITE(*,*)'ANALYTICAL FORCES ON SHIELDING GAUSSIANS:'
      DO I=1,NAT
       WRITE(*,FMT='(10(1X,F15.9))')PCONT(1:NG,I)
      ENDDO
      PCONTX=PCONT
      DO I=1,NAT
       DO J=1,NG
        QMAD(J,I)=QMAD(J,I)+DELT
        CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
          &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
        E2=ECONT
        QMAD(J,I)=QMAD(J,I)-2.D0*DELT
        CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
          &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
        E1=ECONT
        PCONTMEM(J,I)=(E2-E1)/(2.D0*DELT)
        QMAD(J,I)=QMAD(J,I)+DELT
       ENDDO
      ENDDO
      WRITE(*,*)'NUMERICAL FORCES ON SHIELDING GAUSSIANS:'
      DO I=1,NAT
       WRITE(*,FMT='(10(1X,F15.9))')PCONTMEM(1:NG,I)
      ENDDO
      WRITE(*,*)'(NUMERICAL-ANALYTICAL)/ANALYTICAL:'
      DO I=1,NAT
       WRITE(*,FMT='(10(1X,F15.9))')(PCONTMEM(1:NG,I)-PCONTX(1:NG,I))/PCONTX(1:NG,I)
      ENDDO
!
!     ==== NUMERICAL FORCES ON FACE CHARGES ======
!
      CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
         &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
!
      WRITE(*,*)
      WRITE(*,*)'ANALYTICAL FORCES ON FIRST 15 FACE CHARGES:'
      FACE=>FIRSTFACE
        DO I=1,15
      WRITE(*,FMT='(1X,F15.9)')FACE%FQ
      FACE=>FACE%NEXT
      ENDDO
      WRITE(*,*)'NUMERICAL FORCES ON FIRST 15 FACE CHARGES:'
      FACE=>FIRSTFACE
      DO I=1,15
       FACE%Q=FACE%Q+DELT
       CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
         &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
       E2=ECONT
       FACE%Q=FACE%Q-2.D0*DELT
       CALL FORCES_AND_ENERGY(FORCE_ZERO_OVERLAP,MOVE_ATOMS,NAT,R0,&
         &NG,RC,QMAD,ECONT,PCONT,CFORCE,.TRUE.)
       E1=ECONT
       FACE%FMEM=(E2-E1)/(2.D0*DELT)
       WRITE(*,FMT='(1X,F15.9)')FACE%FMEM
       FACE%Q=FACE%Q+DELT
       FACE=>FACE%NEXT
      ENDDO
      END SUBROUTINE NUMERICAL_DERIVATIVES
!     --------------------------------------------
!
      END SUBROUTINE CONTINUUM$PROPAGATE
!
!     =======================================================================
!
      SUBROUTINE CONTINUUM$RETURNPROTOCOL(ON,ESOLV,EKINQ,QFRIC,QTOT)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      LOGICAL ,INTENT(OUT) :: ON
      REAL(8),INTENT(OUT) :: QFRIC,ESOLV,EKINQ,QTOT
      REAL(8) :: F2,F3,F4
      REAL(8) :: NETCHARGE,INSIDE_CHARGE,POSITIVE_INTEGRAL,&
       &NEGATIVE_INTEGRAL,INSIDE_PLUS,INSIDE_MINUS
      INTEGER :: NFILO
!
      CALL GET_SET_ON('GET',ON)
      IF (.NOT. ON) THEN
       ESOLV=0.D0
       EKINQ=0.D0
       QFRIC=0.D0
       RETURN
      ENDIF
!      CALL FILEHANDLER$UNIT('CONTINUUM_PROTOCOL',NFILO)
      CALL GET_SET_CHARGEFRICTION('GET',QFRIC)
      CALL ENERGYLIST$RETURN('TOTAL-SURFACE-POTENTIAL',ESOLV)
      CALL ENERGYLIST$RETURN('SURFACE Q EKIN',EKINQ)
      CALL GET_CHARGE(NETCHARGE,INSIDE_CHARGE,POSITIVE_INTEGRAL,&
       &NEGATIVE_INTEGRAL,INSIDE_PLUS,INSIDE_MINUS)
      QTOT=NETCHARGE
!      WRITE(NFILO,FMT='(6(1X,F12.6))')NETCHARGE,INSIDE_CHARGE,&
!       &POSITIVE_INTEGRAL,NEGATIVE_INTEGRAL,INSIDE_PLUS,INSIDE_MINUS
!
      END SUBROUTINE CONTINUUM$RETURNPROTOCOL
!
!     =======================================================================
!
      SUBROUTINE CONTINUUM$SWITCH(NAT,R0,RM)
      USE CONTINUUM_CONTROL_MODULE
      USE NET_MODULE
      IMPLICIT NONE
      TYPE (FACETYPE),POINTER :: FACE
      INTEGER, INTENT(IN)     :: NAT
      REAL(8),DIMENSION(3,NAT) :: R0,RM
      INTEGER                 :: I,IAT
      LOGICAL                 :: MOVE_ATOMS
!
!     ==== MOVE MIDPOINTS
!
      CALL GET_SET_MOVEATOMS('GET',MOVE_ATOMS)
      IF (.NOT. MOVE_ATOMS) RETURN
!
      DO IAT=1,NAT
       FACE=>FIRSTFACE
       DO WHILE (ASSOCIATED(FACE))
        IF (FACE%ATOM_IDENT == IAT) THEN
         DO I=1,3
          FACE%MIDPOINT(I)=FACE%MIDPOINT(I)+(R0(I,IAT)-RM(I,IAT))
         ENDDO
        ENDIF
        FACE=>FACE%NEXT
       ENDDO
      ENDDO
!
      END SUBROUTINE CONTINUUM$SWITCH
!
!     ================================================================
!
      SUBROUTINE CONTINUUM$SET_THERMOSTAT(TNOSEQ,TSTPNQ,AVEKINQ,FNOSEQ)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      LOGICAL, INTENT(IN) :: TNOSEQ,TSTPNQ
      REAL(8),INTENT(IN) :: AVEKINQ,FNOSEQ
!
      CALL SET_THERMOSTAT(TNOSEQ,TSTPNQ,AVEKINQ,FNOSEQ)
!
      END SUBROUTINE CONTINUUM$SET_THERMOSTAT
!
!     ================================================================
!     ==== INITIALIZES NOSE THERMOSTAT FOR CHARGES ACCORDING TO ======
!     ==== BLOECHL AND PARRINELLO; PRB 45 (1992) 9413           ======
!     ================================================================
!
!
      SUBROUTINE CONTINUUM$NOSE_THERMOSTAT(EKINQ,FRICTION)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
!
      REAL(8),INTENT(OUT)  :: FRICTION
      REAL(8),INTENT(IN)   :: EKINQ
      REAL(8), SAVE :: NOSE_ENERGY,NOSE_MASS,GKBT,AVERAGE_KINETIC,&
                     &NOSE_OMEGA,NOSE_2M,NOSE_M,NOSE_0,NOSE_P,&
                     &NOSE_FREQUENCY,TIMESTEP
      REAL(8)  :: NOSE_VELOCITY
      LOGICAL,SAVE :: ON=.FALSE.,STOP,TFIRST=.TRUE.
      INTEGER :: MULTIPLE
!
!     ----- ON INITIALIZATION, GET SOME CRUCIAL PARAMETERS ---
!
      IF (TFIRST) THEN
       CALL GET_THERMOSTAT(ON,STOP,AVERAGE_KINETIC,NOSE_FREQUENCY)
       TFIRST=.FALSE.
       IF (ON) THEN
        CALL GET_SET_TIMESTEP('GET',TIMESTEP)
        CALL GET_SET_MULTIPLE('GET',MULTIPLE)
        TIMESTEP=TIMESTEP/DBLE(MULTIPLE)
        CALL GET_SET_CHARGEFRICTION('GET',FRICTION)
        NOSE_ENERGY=0.D0
        GKBT=2.D0*AVERAGE_KINETIC
!     ----- DETERMINE MASS THROUGH APPROXIMATE EIGENFREQUENCY -----
        NOSE_OMEGA=NOSE_FREQUENCY*(8.D0*DATAN(1.D0))
        NOSE_MASS=2.D0/NOSE_OMEGA**2*GKBT
        IF (STOP) THEN
         NOSE_0 =0.D0
         NOSE_2M=0.D0
         NOSE_M =0.D0
        ELSE
         NOSE_2M=-2.D0*FRICTION/TIMESTEP
         NOSE_M =-FRICTION/TIMESTEP
         NOSE_0 =0.D0
        END IF
       ENDIF
      ENDIF
!
!     ----- IF THE THERMOSTAT IS OFF, HAND BACK ZERO FRICTION ----
!
      IF (.NOT. ON) THEN
       FRICTION=0.D0
       RETURN
      ENDIF
!
!     ----- DETERMINE FRICTION FROM NOSE VARIABLE ----
!
!
!     ----- 1) PROPAGATE NOSE VARIABLE ---
!
      NOSE_P=2.D0*NOSE_0-NOSE_M+TIMESTEP**2/NOSE_MASS*(2.D0*EKINQ-GKBT)
!
!     ----- 2) CALCULATE VELOCITY - > FRICTION -----
!
      NOSE_VELOCITY=(NOSE_P-NOSE_M)/(2.D0*TIMESTEP)
      FRICTION=NOSE_VELOCITY*TIMESTEP/2.D0
      NOSE_ENERGY=0.5D0*NOSE_MASS*((NOSE_P-NOSE_M)/(2.D0*TIMESTEP))&
        &**2+GKBT*NOSE_0
      CALL ENERGYLIST$SET('CHARGE THERMOSTAT',NOSE_ENERGY)
      CALL ENERGYLIST$ADD('CONSTANT ENERGY',NOSE_ENERGY)
!
!     ---- SWITCH NOSE VARIABLES ----
!
      NOSE_2M=NOSE_M
      NOSE_M =NOSE_0
      NOSE_0 =NOSE_P
!
!     ==============================================================
!     ======= THE FOLLOWING ALTERNATIVE CALCULATES THE VELOCITY ====
!     ======= FROM THE TWO PREVIOUS TIMESTEPS ======
!!
!!     ----- DETERMINE FRICTION FROM NOSE VARIABLE ----
!!
!      NOSE_VELOCITY=(3.D0*NOSE_0-4.D0*NOSE_M+NOSE_2M)/(2.D0*TIMESTEP)
!      FRICTION=NOSE_VELOCITY*TIMESTEP/2.D0
!!
!!     ----- PROPAGATE NOSE VARIABLE ---
!!
!      NOSE_P=2.D0*NOSE_0-NOSE_M+TIMESTEP**2/NOSE_MASS*(2.D0*EKINQ-GKBT)
!     ==============================================================
!
      END SUBROUTINE CONTINUUM$NOSE_THERMOSTAT
!
!
!
      SUBROUTINE CONTINUUM$SETL4(ID_,VALUE_)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      CHARACTER(*),INTENT(IN):: ID_
      LOGICAL(4),INTENT(IN)   :: VALUE_
!
      IF (ID_ == 'MOVE') THEN
       CALL GET_SET_MOVEATOMS('SET',VALUE_)
      ELSE IF (ID_ == 'ON') THEN
       CALL GET_SET_ON('SET',VALUE_)
      ELSE IF (ID_ == 'START') THEN
       CALL GET_SET_RESTART('SET',.NOT.VALUE_)
      ELSE IF (ID_ == 'FREEZE') THEN
       CALL GET_SET_MOVENETCHARGES('SET',.NOT.VALUE_)
      ELSE IF (ID_ == 'EXCLUDEOVERLAP') THEN
       CALL GET_SET_FZO('SET',VALUE_)
      ELSE IF (ID_ == 'STOP') THEN
       CALL GET_SET_STOPNETCHARGES('SET',VALUE_)
      ELSE
       PRINT*,'CONTINUUM_SETL4 COULD NOT ASSOCIATE AN IDENTIFIER :',ID_
      ENDIF
!
      END SUBROUTINE CONTINUUM$SETL4
!
!
!
      SUBROUTINE CONTINUUM$SETR8(ID_,VALUE_)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      CHARACTER(*) :: ID_
      REAL(8)      :: VALUE_
!
      IF (ID_ == 'TIMESTEP') THEN
        CALL GET_SET_TIMESTEP('SET',VALUE_)
      ELSE IF (ID_ == 'MASS') THEN
       CALL GET_SET_SURFACEMASS('SET',VALUE_)
      ELSE IF (ID_ == 'EPSILON') THEN
       CALL GET_SET_SCALINGFACTOR('SET',VALUE_/(VALUE_-1.D0))
      ELSE IF (ID_ == 'FRICTION') THEN
       CALL GET_SET_CHARGEFRICTION('SET',VALUE_)
      ELSE
       PRINT*,'CONTINUUM_SETR8 COULD NOT ASSOCIATE AN IDENTIFIER :',ID_
      ENDIF
!
      END SUBROUTINE CONTINUUM$SETR8
!
!
!
      SUBROUTINE CONTINUUM$SETR8A(ID_,LENGTH_,VALUE_)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      CHARACTER(*) :: ID_
      INTEGER(4)   :: LENGTH_
      REAL(8),DIMENSION(LENGTH_)    :: VALUE_
      INTEGER(4)               :: COUNTER
!
      IF (ID_ == 'RAD') THEN
       CALL GET_SET_RSOLV('SET',LENGTH_,VALUE_)
      ELSE 
       PRINT*,'CONTINUUM_SETR8A COULD NOT ASSOCIATE AN DIDENTIFIER:',ID_
      ENDIF
! 
      END SUBROUTINE CONTINUUM$SETR8A
!
!
!
      SUBROUTINE CONTINUUM$SETCHA(ID_,LENGTH_,VALUE_)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      CHARACTER(*)  :: ID_
      INTEGER(4)    :: LENGTH_
      CHARACTER(*)  :: VALUE_(LENGTH_)
      INTEGER(4) :: I,NAT
      CHARACTER(8),ALLOCATABLE,DIMENSION(:) ::  FILEID
! 
      ALLOCATE(FILEID(LENGTH_))
      IF (ID_ == 'TESS') THEN
       CALL ATOMLIST$NATOM(NAT)
       IF (NAT /= LENGTH_) THEN
        CALL ERROR$MSG('SIZE INCONSISTENT')
        CALL ERROR$CHVAL('ID_',ID_)
        CALL ERROR$STOP('CONTINUUM$SETCHA')
       END IF
       DO I=1,LENGTH_
         WRITE(FILEID(I),FMT='("TESS",I4)')I
         CALL FILEHANDLER$SETFILE(FILEID(I),.FALSE.,VALUE_(I))
         CALL FILEHANDLER$SETSPECIFICATION(FILEID(I),'FORM','FORMATTED')
       ENDDO
       CALL GET_SET_TESSNAME('SET',LENGTH_,FILEID)
      ELSE
        CALL ERROR$MSG('ID NOT RECOGNIZED')
        CALL ERROR$CHVAL('ID_',ID_)
        CALL ERROR$STOP('CONTINUUM$SETCHA')
      END IF
      DEALLOCATE(FILEID)
!
      END SUBROUTINE CONTINUUM$SETCHA
!
!
!
      SUBROUTINE CONTINUUM$SETI4(ID_,VALUE_)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      CHARACTER(*),INTENT(IN):: ID_
      INTEGER(4),INTENT(IN)   :: VALUE_
!
      IF (ID_ == 'MULTIPLE') THEN
       CALL GET_SET_MULTIPLE('SET',VALUE_)
      ELSE 
       PRINT*,'CONTINUUM_SETI4 COULD NOT ASSOCIATE AN IDENTIFIER:',ID_
      ENDIF
!
      END SUBROUTINE CONTINUUM$SETI4
!
!
!
      SUBROUTINE CONTINUUM$PRLINE(NFILO)
      USE CONTINUUM_CONTROL_MODULE
      IMPLICIT NONE
      INTEGER :: NFILO
      REAL(8) :: EKINQ,ESOLV,QFRIC
      REAL(8) :: NETCHARGE,INSIDE_CHARGE,POSITIVE_INTEGRAL,&
       & NEGATIVE_INTEGRAL,INSIDE_PLUS,INSIDE_MINUS
!
      CALL GET_SET_CHARGEFRICTION('GET',QFRIC)
      CALL ENERGYLIST$RETURN('TOTAL-SURFACE-POTENTIAL',ESOLV)
      CALL ENERGYLIST$RETURN('SURFACE Q EKIN',EKINQ)
      CALL GET_CHARGE(NETCHARGE,INSIDE_CHARGE,POSITIVE_INTEGRAL,&
       &NEGATIVE_INTEGRAL,INSIDE_PLUS,INSIDE_MINUS)
      WRITE(NFILO,FMT='("FRIC: ",F15.9," ESOLV :",F15.9," EKINQ :",F15.9)') &
     &            QFRIC,ESOLV,EKINQ
      PRINT*,NETCHARGE,INSIDE_CHARGE,POSITIVE_INTEGRAL,&
        & NEGATIVE_INTEGRAL,INSIDE_PLUS,INSIDE_MINUS
!
      END SUBROUTINE CONTINUUM$PRLINE
!
!
!
!     ..................................................................
      SUBROUTINE CONTINUUM$READ(NFIL,NFILO,TCHK)
!     ******************************************************************
!     ******************************************************************
      USE RESTART_INTERFACE
      USE CONTINUUM_CONTROL_MODULE, ONLY : GET_SET_RESTART,GET_SET_ON
      USE NET_MODULE
      USE MPE_MODULE
      IMPLICIT NONE
      INTEGER(4)            ,INTENT(IN)  :: NFIL
      INTEGER(4)            ,INTENT(IN)  :: NFILO
      LOGICAL(4)            ,INTENT(OUT) :: TCHK
      LOGICAL(4)                         :: RESTART
      TYPE (SEPARATOR_TYPE),PARAMETER    :: MYSEPARATOR &
             =SEPARATOR_TYPE(2,'CONTINUUM','NONE','JUN1997','NONE')
      TYPE (SEPARATOR_TYPE)              :: SEPARATOR
      INTEGER(4)                         :: NTASKS,THISTASK
      LOGICAL(4)                         :: TON
!     ******************************************************************
      CALL GET_SET_ON('GET',TON)
      CALL GET_SET_RESTART('GET',RESTART)
      TCHK=RESTART.AND.TON
      SEPARATOR=MYSEPARATOR
      CALL MPE$QUERY('MONOMER',NTASKS,THISTASK)
      IF(THISTASK.EQ.1)CALL RESTART$READSEPARATOR(SEPARATOR,NFIL,NFILO,TCHK)
      CALL MPE$BROADCAST('MONOMER',1,TCHK)
!PRINT*,'SEPARATOR',SEPARATOR
!PRINT*,'MYPARATOR',MYSEPARATOR
!PRINT*,' READING ? ',TCHK
      IF(.NOT.TCHK) RETURN
!
      IF(SEPARATOR%VERSION.NE.MYSEPARATOR%VERSION) THEN
        CALL ERROR$MSG('VERSION NOT RECOGNIZED')
        CALL ERROR$CHVAL('ACTUALVERSION ',MYSEPARATOR%VERSION)
        CALL ERROR$CHVAL('VERSION ',SEPARATOR%VERSION)
        CALL ERROR$STOP('CONTINUUM$READ')
      END IF
      CALL CONTINUUM_READ(NFIL)

      RETURN
      END
!
!     ..................................................................
      SUBROUTINE CONTINUUM$WRITE(NFIL,NFILO,TCHK)
!     ******************************************************************
      USE RESTART_INTERFACE
      USE CONTINUUM_CONTROL_MODULE, ONLY : GET_SET_ON
      USE NET_MODULE
      IMPLICIT NONE
      INTEGER(4)       ,INTENT(IN)  :: NFIL
      INTEGER(4)       ,INTENT(IN)  :: NFILO
      LOGICAL(4)       ,INTENT(OUT) :: TCHK
      TYPE (SEPARATOR_TYPE),PARAMETER   :: MYSEPARATOR &
             =SEPARATOR_TYPE(2,'CONTINUUM','NONE','JUN1997','NONE')
      INTEGER(4)                    :: NTASKS,THISTASK,NAT
      REAL(8), ALLOCATABLE          :: R(:,:)
      LOGICAL(4)                         :: TON
!     ******************************************************************
      CALL GET_SET_ON('GET',TON)
      IF(.NOT.TON) RETURN
      CALL MPE$QUERY('MONOMER',NTASKS,THISTASK)
      IF(THISTASK.NE.1) RETURN
      TCHK=.TRUE.
      CALL RESTART$WRITESEPARATOR(MYSEPARATOR,NFIL,NFILO,TCHK)
      CALL CONTINUUM_WRITE(NFIL)
!
      CALL ATOMLIST$NATOM(NAT)
      ALLOCATE(R(3,NAT))
      CALL ATOMLIST$GETR8A('R(0)',0,3*NAT,R)
      CALL NET_REPORT(NAT,R)
!
      RETURN
      END


